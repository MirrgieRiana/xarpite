---
title: "範囲系演算子"
---

<!-- toc -->

# 範囲系演算子

## 閉区間 `start .. end`

閉区間演算子は、左辺から右辺までの整数の範囲のストリームを生成します。

end自身はストリームに含まれます。

```shell
$ xa '1 .. 3'
# 1
# 2
# 3
```

---

左辺が右辺よりも大きい場合、カウントダウンを行います。

```shell
$ xa '3 .. 1'
# 3
# 2
# 1
```

## 半開区間 `start ~ end`

半開区間演算子は、左辺から右辺の1つ手前までの整数の範囲のストリームを生成します。

end自身はストリームに含まれません。

```shell
$ xa '1 ~ 3'
# 1
# 2
```

---

半開区間演算子は、閉区間演算子とは異なり、右辺が左辺よりも大きい場合、空のストリームを生成します。

```shell
$ xa '[3 ~ 1]'
# []
```

# ストリーム結合系演算子

## ストリームの結合 `items, ...`

演算子 `,` は、左右の要素またはストリームを結合したストリームを生成します。

Xarpiteでは、ラムダ演算子の左辺のような特殊な場所でない限り、 `,` は引数や配列要素等の区切りではなくストリーム結合演算子として解釈されます。

```shell
$ xa '1, 2 .. 4, 5'
# 1
# 2
# 3
# 4
# 5
```

---

ストリーム結合演算子は余計に多く書いても無視されます。

```shell
$ xa ', , 1, , , , 2, , '
# 1
# 2
```

---

ストリーム結合演算子のみを記述することができ、その場合は空ストリームを生成します。

```shell
$ xa '[,]'
# []
```

---

xaコマンドはデフォルトの挙動で与えられたソースコードの戻り値を出力しますが、空のストリームに対しては何も出力しないため、xaコマンドの出力を抑制するのに使われることもあります。

```shell
$ xa '"何らかの副作用を伴う処理"; ,'
```

# ストリーム系演算子

ストリーム系演算子は、ストリームの加工や代入などを行う演算子です。

## ストリーム系演算子の簡単な紹介

結合優先度についての解説のため、ストリーム系に属する演算子を軽く紹介します。

---

パイプ `stream | argument => formula` は、 `stream` の各要素について `formula` を適用したストリームを得ます。

`formula` 内では、 `argument` でその要素を参照できます。

```shell
$ xa '1, 2, 3 | x => x * 10'
# 10
# 20
# 30
```

---

実行パイプ `value >> function` は、 `function` に `value` を渡して実行します。

```shell
$ xa '1, 2, 3 >> REVERSE'
# 3
# 2
# 1
```

---

変数宣言 `variable := value` は、変数 `variable` を宣言しつつ、その値を `value` で初期化します。

```shell
$ xa '
  x := 123
  x
'
# 123
```

---

代入 `variable = value` は、変数 `variable` に `value` を代入します。

```shell
$ xa '
  x := 123
  x = 456
  x
'
# 456
```

## 結合優先度について

ストリーム系演算子は、実用上の理由から、以下の文法で表される複雑な結合規則を持っています。

```
ストリームノード :=
    ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード  ストリーム後方付加部*

ストリーム後方付加部 :=
    パイプ演算子  パイプ右辺
  / 実行パイプ演算子  実行パイプ右辺

実行パイプ右辺 :=
    ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード

パイプ右辺 :=
    ストリーム結合ノード  パイプ系演算子  パイプ右辺
  / ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード
```

以下では、ストリーム系演算子の文法を例を用いて解説します。

---

パイプ系演算子は、原則として右優先結合です。

このため、前段の変数を後段から参照することができます。

```shell
$ xa '10, 20 | x => 3, 4 | y => x + y'
# 13
# 14
# 23
# 24

$ xa '10, 20 | x => (3, 4 | y => x + y)'
# 13
# 14
# 23
# 24
```

---

実行パイプ系演算子は、左側にあるパイプ系・実行パイプ系演算子をまとめて取ります。

これにより、様々に加工したストリームの全体を関数に入力することができます。

```shell
$ xa '10, 20 | x => 3, 4 | y => x + y >> JOIN["-"]'
# 13-14-23-24

$ xa '(10, 20 | x => 3, 4 | y => x + y) >> JOIN["-"]'
# 13-14-23-24
```

実行パイプ系演算子は他の実行パイプ系演算子も左辺にまとめて取ります。

また、実行パイプ系演算子による結果を、さらに別のパイプ系演算子で加工出来ます。

```shell
$ xa '1 .. 3 | _ * 10 >> REVERSE | _ + 5 >> JOIN["-"]'
# 35-25-15

$ xa '((1 .. 3 | _ * 10) >> REVERSE | _ + 5) >> JOIN["-"]'
# 35-25-15
```

---

代入系演算子は、右辺を左辺から分離します。

代入系演算子の右辺にある実行パイプ系演算子は、代入系演算子の左辺には影響を及ぼしません。

```shell
$ xa '
  pow2_joiner := stream -> stream | x => x * x >> JOIN["-"]
  pow2_joiner(1, 2, 3)
'
# 1-4-9
```

以下では、関数 `setter` を呼び出すと、与えた数値に36を足して平方根を取った値を変数 `variable` に代入します。

`SQRT` の左にある `>>` は、その左の `=` の手前までを左辺に取ります。

```shell
$ xa '
  variable := NULL
  setter := x -> x + 36 | x2 => variable = x2 >> SQRT
  setter(64)
  variable
'
# 10.0
```

## 配列の要素への代入（代入系） `array(index) = value`

左辺が配列の要素の参照であった場合、その要素に右辺の値を代入します。

```shell
$ xa -q '
  array := [1, 2, 3]
  OUT << array
  array(1) = 4
  OUT << array
'
# [1;2;3]
# [1;4;3]
```

## エントリー演算子（代入系） `key: value`

エントリー演算子は、両辺を要素とする2要素の配列を生成する演算子です。

```shell
$ xa 'a: 1'
# [a;1]
```

---

左辺が識別子の場合、同名の変数があっても、変数を参照するのではなく文字列として扱います。

```shell
$ xa '
  a := "b"
  a: 1
'
# [a;1]
```

---

左辺で変数を参照したい場合は、括弧で囲むことで文字列として扱われることを回避できます。

```shell
$ xa '
  a := "b"
  (a): 1
'
# [b;1]
```

---

エントリー演算子は配列リテラルとは異なり、ストリームを展開せず、常に2要素の配列を生成します。

```shell
$ xa '["key"; 1 .. 3]'
# [key;1;2;3]

$ xa 'key: 1 .. 3'
# [key;123]
```

---

この演算子はオブジェクトを生成する際に有用です。

```shell
$ xa '
  {
    a: 1
    b: 2
  }
'
# {a:1;b:2}
```

## 左実行パイプ（代入系） `function << value`

左実行パイプは、右辺の値を左辺の関数の第1引数に指定して呼び出します。

右実行パイプの左右が逆のバージョンですが、結合優先度が代入系扱いです。

使い方によっては可読性に貢献する可能性を秘めています。

```shell
$ xa -q '
  OUT << "Hello, World"
'
# Hello, World
```

## パイプ（パイプ系） `stream | formula`

パイプ演算子 `|` は、左辺のストリームの各値に対して右辺を評価し、そのフラットなストリームを返します。

右辺では、変数 `_` によって左辺の各要素の値を得ることができます。

```shell
$ xa '1 .. 3 | _, _ * 10'
# 1
# 10
# 2
# 20
# 3
# 30
```

---

左辺がストリームでない場合、右辺の返却値はストリームで改めてラッピングされることなく、そのままの型で返されます。

```shell
$ xa '(5 | _ * 10) + 7'
# 57
```

---

右辺に渡される変数は `=>` によって変更できます。

```shell
$ xa '5 | x => x * 10'
# 50
```

---

右辺の引数を `index, value => formula` の形式にすることで、左辺のストリームの各要素のインデックスと値を取得できます。

```shell
$ xa '"a", "b", "c" | i, v => "$i: $v"'
# 0: a
# 1: b
# 2: c
```

---

パイプ演算子をループ構文のように使うこともできます。

```shell
$ xa '
  x := 0
  1 .. 10 | (
    x = x + _
  )
  x
'
# 55
```

---

ループ変数は右辺が評価されるごとに独立して作られます。

このため、ループの進行によって変数の内容が変わったり、変数への代入が異なる評価の間で影響し合うことはありません。

```shell
$ xa '
  accessors := [1 .. 4 | value => {
    set: _ -> value = _
    get: , -> value
  }]
  accessors.2.set() = 99
  accessors().get()
'
# 1
# 2
# 99
# 4
```

## 右実行パイプ（実行パイプ系） `value >> function`

右実行パイプは、左辺の値を右辺の関数の第1引数に指定して呼び出します。

```shell
$ xa '1 .. 3 >> JOIN["-"]'
# 1-2-3
```

---

この演算子はストリームを扱う関数の実行に便利です。

```shell
$ xa '"1+2+3" >> SPLIT["+"] | +_ * 2 >> JOIN["-"]'
# 2-4-6
```

## オブジェクトの継承 `parent{entry; ...}`

オブジェクトに `{` `}` を後置すると、そのオブジェクトを親とする子オブジェクトを生成します。

オブジェクトの継承は主にメソッドの検索に使われ、エントリーの継承は行われません。

オブジェクトの生成方法はオブジェクトリテラルと共通です。

```shell
$ xa '{a: 1; m: this -> 3}{b: 2}'
# {b:2}

$ xa '{a: 1; m: this -> 3}{b: 2}.a'
# NULL

$ xa '{a: 1; m: this -> 3}{b: 2}::m()'
# 3
```

## オブジェクトの要素アクセス `object.key`

`.` 演算子でオブジェクトの要素にアクセスできます。

```shell
$ xa '{x: 123}.x'
# 123
```

---

オブジェクトが親オブジェクトを持つ場合でも、親オブジェクトの要素は継承されません。

```shell
$ xa '{x: 123}{}.x'
# NULL
```

---

`.` の右辺に括弧を置くことで、任意の式によって参照できます。

```shell
$ xa '
  obj := {item1: 123; item2: 456}
  index := 2
  obj.("item$index")
'
# 456
```

---

`.` は、右辺が識別子の場合、それを変数ではなくキーとして解釈する性質があります。

したがって、括弧の有無によって参照するエントリーに違いが現れます。

```shell
$ xa '
  key := "item1"
  obj := {key: 123; item1: 456}
  [obj.key; obj.(key)]
'
# [123;456]
```

---

キーは自動的に文字列化されます。

```shell
$ xa '{1: 123}.1'
# 123
```

## Null安全要素アクセス `object?.key`

`?.` 演算子は左辺が `NULL` の場合に、要素の取得を試みる代わりに `NULL` を返します。

```shell
$ xa '{x: 1}, NULL, {x: 3} | _?.x'
# 1
# NULL
# 3
```

# パイプと実行パイプのインデントのベストプラクティス

パイプ演算子 `|` と実行パイプ演算子 `>>` はその左右どちらでも改行でき、ある程度自由に記述できます。

ここではベストプラクティスとして推奨されるインデントスタイルを示します。

## パイプの連鎖

`|` の位置で改行する場合、その直後もしくはそれに続く `=>` の直後で改行し、右辺をインデントをします。

こうすることで、行頭が常に式の先頭になり、一貫します。

```
a |
  b
```

```
a | b =>
  c
```

連鎖する場合も同様です。

```
a | b =>
  c |
    d | e =>
      f
```

## 実行パイプによるパイプのインデントのリセット

`>>` の位置で改行する場合、その直前で改行しつつ、それまでの `|` 演算子によるインデントをすべて解除します。

こうすることで、 `|` によって宣言されたループ変数のスコープが `>>` の直前で切れたことが明瞭になります。

```
a |
  b | c =>
    d
>> e
>> f
```

`>>` の後に `|` が続く場合、 `|` の前で改行します。

これにより、 `>>` のある行のスタイルが一貫します。

```
a | b =>
  c
>> b
>> e
| f =>
  g |
    h
>> i
```

# ストリームのプロパティアクセス

ストリームに対してプロパティアクセスをすると、各要素のプロパティアクセスの結果を結合したストリームを返します。

```shell
$ xa '
  (
    {a: 1},
    {a: 2 .. 4},
  ).a
'
# 1
# 2
# 3
# 4
```

# ストリームの解決

戻り値としてストリームを返却する演算子や関数は、ストリームの副作用の保証のためにストリームの解決を行う場合があります。

ストリームの解決とは、本来のストリームの代わりに、その要素列を再現するキャッシュのストリームを返すことをいいます。

本来のストリームは解決時に丁度1回だけ全体が評価され、その際に副作用も丁度1回だけ発生します。

---

この動作は、ストリームという値が本質的に遅延評価される命令の塊であることに起因します。

例えば、以下の例では `stream` の実際のイテレーションの開始はプログラム全体の結果を実際に出力するまで遅延されます。

```shell
$ xa '
  array := [1, 2, 3]
  stream := array()
  array::push << 4, 5
  stream
'
# 1
# 2
# 3
# 4
# 5
```

この性質は、副作用の効果を期待するプログラムでは邪魔になることがあります。

以下の例では、パイプ演算子を使って配列に要素を追加することを期待していますが、2番目の例は副作用が発生しません。

```shell
$ xa '
  array := [1, 2, 3]
  4, 5 | *array::push
  array
'
# [1;2;3;4;5]

$ xa '
  array := [1, 2, 3]
  dummy := 4, 5 | *array::push
  array
'
# [1;2;3]
```

ストリームの解決を行い、副作用をその場で発生させる簡単な方法は、複文によって文（runner）として実行させることです。

```shell
$ xa '
  array := [1, 2, 3]
  dummy := (4, 5 | *array::push;)
  array
'
# [1;2;3;4;5]
```

---

キャッシュ用の配列の保持は、解決されたストリームの結果がどこにも使われない場合、メモリ節約のために省略される場合があります。

# ストリーム系関数

## `PIPE`: 読み取り位置を記憶するストリームを生成する

`<T> PIPE(stream: STREAM<T>): STREAM<T>`

`stream` のイテレーションを保持し、イテレート時に保持した位置から再開するストリームを生成します。

---

このような性質を持つストリームは、便宜上「パイプ」と呼ばれます。

CLI上で標準入力を受け付ける `IN` などもパイプに相当します。

パイプは `FIRST` や `TAKE` などのストリームを中途半端に消費する関数と組み合わせることで真価を発揮します。

```shell
$ xa -q '
  pipe := PIPE(1 .. 10)
  OUT << "First: " & FIRST(pipe)
  OUT << "Next 3 items: " & [pipe >> TAKE[3]]
  OUT << "Next: " & FIRST(pipe)
'
# First: 1
# Next 3 items: [2;3;4]
# Next: 5
```

---

読み切ったパイプは空ストリームになります。

```shell
$ xa -q '
  pipe := PIPE(1 .. 10)
  OUT << [pipe]
  OUT << [pipe]
'
# [1;2;3;4;5;6;7;8;9;10]
# []
```

---

性質上、返されるストリームを通じて、 `stream` は高々1度のみイテレートされます。

これにより `stream` が引き起こす副作用も複数回発生することはありません。

```shell
$ xa '
  array := []
  pipe := PIPE(
    1 .. 3 | (
      array::push << _
    )
  )

  pipe
  pipe
  pipe

  array
'
# [1;2;3]
```

---

ただし、 `PIPE` は `stream` の要素をバッファリングする可能性があり、副作用が意図しないタイミングで発生する可能性があります。

副作用のタイミングを制御するには、副作用のある処理を関数にし、パイプから取り出した側でそれを実行します。

```shell
$ xa -q '
  tasks := PIPE(
    1 .. 10 | , -> (
      OUT << "Task $_"
    )
  )

  OUT << "Execute 1 task"
  FIRST(tasks) | _()
  OUT << "Execute 3 tasks"
  TAKE(3; tasks) | _()
  OUT << "Execute 1 task"
  FIRST(tasks) | _()
'
# Execute 1 task
# Task 1
# Execute 3 tasks
# Task 2
# Task 3
# Task 4
# Execute 1 task
# Task 5
```

---

`PIPE` は遅延評価であり、返されたストリームが消費されない場合、 `stream` のイテレーションは開始されません。

したがって、副作用も発生しません。

```shell
$ xa '
  array := []
  pipe := PIPE(
    1 .. 10000 | (
      array::push << _
    )
  )
  array
'
# []
```
