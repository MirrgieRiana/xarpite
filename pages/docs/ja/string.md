---
title: "生文字列リテラル `'contents'`"
---

<!-- toc -->

# 生文字列リテラル `'contents'`

生文字列リテラルは `'` `'` で囲まれた文字列であり、ほとんどの文字をそのまま解釈します。

| 文字列     | 意味      |
|---------|---------|
| `''`    | `'`     |
| CRLF    | LF      |
| CR      | LF      |
| LF      | LF      |
| `'`     | 生文字列の終端 |
| それ以外の文字 | その文字自身  |

## シングルクォートコンテント `''`

生文字列内で `'` を記述するには `''` と書きます。

```shell
$ xa " 'abc''def' "
# abc'def
```

## 改行コンテント

生文字列内には改行を含めることができますが、すべてLFに統一されます。

この性質は、ソースコードの改行コードが変更されてもプログラムの動作が変わらないことを保証します。

```shell
$ xa " 'abc
def' "
# abc
# def
```

## 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

これは `$` や ` \ ` も例外ではありません。

```shell
$ xa \''abc$def\nop'\'
# abc$def\nop
```

# テンプレート文字列リテラル `"contents"`

テンプレート文字列リテラルは `"` `"` で囲まれた文字列であり、エスケープや埋め込みなどの機能が使えます。

| 文字列                   | 意味                           |
|-----------------------|------------------------------|
| `\"`                  | `"`                          |
| `\$`                  | `$`                          |
| ` \\ `                | ` \ `                        |
| `\t`                  | タブ文字                         |
| `\r`                  | CR                           |
| `\n`                  | LF                           |
| `\xXX`                | 指定したコードポイントU+0000～U+00FFの1文字 |
| `\uXXXX`              | 指定したUTF-16のコード単位1個           |
| 上記以外の ` \ ` で始まるシーケンス | 構文エラー                        |
| CRLF                  | LF                           |
| CR                    | LF                           |
| LF                    | LF                           |
| `$` 識別子や括弧類など         | 埋め込み                         |
| `$%` フォーマット指定子 括弧類    | フォーマット付き埋め込み                 |
| `"`                   | テンプレート文字列の終端                 |
| それ以外の文字               | その文字自身                       |

## エスケープシーケンスコンテント `\n`

エスケープシーケンスコンテントは ` \ ` で始まる一連のシーケンスであり、それぞれ決められた文字を表します。

エスケープシーケンスの一覧は上記の表を参照してください。

` \ ` で始まるシーケンスは将来の機能のために予約されており、不正なシーケンスは構文エラーとなります。

```shell
$ xa ' "abc\"def\\ghi\njkl" '
# abc"def\ghi
# jkl
```

---

Unicodeの1文字を指定するエスケープシーケンス（文字参照）も利用できます。

```shell
$ xa ' "\u3042" '
# あ
```

## 改行コンテント

生文字列リテラルの改行コンテントと同様です。

## 埋め込みコンテント `$factor`

`$` に続いて任意の識別子、リテラル、括弧類を記述でき、その値は文字列化されたうえで文字列に埋め込まれます。

最も一般的な利用形態は、丸括弧によって任意の式を埋め込むことや、単一の識別子を埋め込むことです。

```shell
$ xa ' "value is $(100 + 20 + 3)" '
# value is 123

$ xa '
  value := 123
  "value is $value"
'
# value is 123
```

## フォーマット付き埋め込みコンテント `$%-+ 07.2f(value)`

フォーマット付き埋め込みコンテントは通常の埋め込みコンテントに似ていますが、以下の点で異なります。

- `$` に続いて、 `%` から始まるフォーマット指定子を記述します。
- 識別子などを直接埋め込むことはできず、括弧類に限られます。

```shell
$ xa ' "[$%+09.2f(123)]" '
# [+00123.00]
```

---

フォーマット指定子の文法は以下の通りです。

1. `%`

- 必須のマジックワードです。

2. フラグ（省略可能）

- 下表のフラグを0個以上指定することができます。

3. 幅（省略可能）

- 文字列の長さが幅未満である場合に半角空白で補充します。

4. `.` 精度（省略可能）

- 表示する小数の桁数を指定します。
- 精度が下がる場合、四捨五入が行われます。
- 切り捨てられる部分が丁度中間の場合、常に絶対値の大きい側に丸められます。

5. 変換

- 下表の変換を指定します。

| フラグ  | 意味                   |
|------|----------------------|
| `-`  | 左揃えにします。             |
| `+`  | 符号を常に表示します。          |
| 半角空白 | 符号のための半角空白を表示します。    |
| `0`  | スペースの代わりに `0` で埋めます。 |

| 変換 | 意味         |
|----|------------|
| d  | 10進整数      |
| x  | 16進整数（小文字） |
| X  | 16進整数（大文字） |
| f  | 10進小数      |
| s  | 文字列        |

## 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

# 埋め込み文字列リテラル `%>contents<%`

埋め込み文字列リテラルは `%>` `<%` で囲われた独特な見た目の文字列リテラルです。

| 文字列          | 意味         |
|--------------|------------|
| `<%%`        | `<%`       |
| CRLF         | LF         |
| CR           | LF         |
| LF           | LF         |
| `<%=` 式 `%>` | 埋め込み       |
| `<%`         | 埋め込み文字列の終端 |
| それ以外の文字      | その文字自身     |

---

埋め込み文字列リテラルは、特にHTMLコードの生成と相性がよいです。

```shell
$ xa '
  %>
    <table>
      <tr style="color: red;"><th>x</th><th>x×10</th></tr>
      <%= 1 .. 3 | x => %>
        <tr><td><%= x %></td><td><%= x * 10 %></td></tr>
      <% %>
    </table>
  <%
'
#     <table>
#       <tr style="color: red;"><th>x</th><th>x×10</th></tr>
#
#         <tr><td>1</td><td>10</td></tr>
#
#         <tr><td>2</td><td>20</td></tr>
#
#         <tr><td>3</td><td>30</td></tr>
#
#     </table>
```

<table>
  <tr style="color: red;"><th>x</th><th>x×10</th></tr>
  <tr><td>1</td><td>10</td></tr>
  <tr><td>2</td><td>20</td></tr>
  <tr><td>3</td><td>30</td></tr>
</table>

## 埋め込み文字列終了シーケンスコンテント `<%%`

埋め込み文字列内で `<%` を記述するには `<%%` と書きます。

```shell
$ xa '%>[ <%% ]<%'
# [ <% ]
```

## 改行コンテント

生文字列リテラルの改行コンテントと同様です。

## 埋め込みコンテント `<%= value %>`

`<%=` `%>` で囲うと任意の値を文字列化したうえで埋め込むことができます。

丸括弧と同様、内部で宣言された変数が外部に出ない効果があります。

```shell
$ xa ' %>value is <%= 100 + 20 + 3 %><% '
# value is 123
```

## 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

# 文字列の各文字のストリーム化 `string()`

文字列の各文字を順番にイテレートするストリームを返します。

```shell
$ xa '"abc"()'
# a
# b
# c
```

# 文字列の要素アクセス `string(index)`

配列と同様、文字列の要素にインデックスでアクセスできます。

```shell
$ xa '"abc"(1)'
# b

$ xa '"abc"(-1)'
# c

$ xa '"abc"(2, 0)'
# c
# a
```

# 文字列の要素アクセス `string.index`

`.` 演算子で文字列の要素にアクセスできます。

```shell
$ xa '"abc".1'
# b
```

---

オブジェクトの要素アクセスと同様に、 `.` の右辺を式にすることができます。

```shell
$ xa '"abc".(1 + 1)'
# c
```

---

添え字が負数であった場合は `NULL` が返されます。

```shell
$ xa '"abc".(-1)'
# NULL
```

---

インデックスは数値化されたあと、四捨五入されて評価されます。

```shell
$ xa '"abc".("0.95")'
# b
```

# 文字列化 `&value`

前置 `&` 演算子は、値の文字列表現を得るのに使います。

```shell
$ xa '&[1..3]'
# [1;2;3]
```

---

値のタイプごとの文字列表現は以下の通りです。

- NULLは `NULL` になります。
- 整数値の文字列表現は、その整数値の10進数表現になります。
- TRUEは `TRUE` 、FALSEは `FALSE` になります。
- 文字列の文字列表現は、その文字列自身です。
- 配列の文字列表現は、 `[1;2;3]` のように、 `;` で区切って `[` `]` で囲んだものです。
- オブジェクトの文字列表現は、 `{a:1;b:2}` のように、キーと値を `:` で区切り、そのエントリーを `;` で区切り、全体を `{` `}` で囲んだものです。

---

文字列化の実態は、値の `&_` メソッドを呼び出すことで行われます。

オブジェクトの `&_` メソッドをオーバーライドすることで、文字列化の処理を変更することができます。

```shell
$ xa '&{`&_`: this -> "The value is $(this.value)"}{value: 100}'
# The value is 100
```

# 文字列の結合 `string & string`

文字列の連結を行うには `&` 演算子を使います。

```shell
$ xa '"abc" & "def"'
# abcdef
```

# 部分文字列の取得

`string[indices]` で部分文字列を取得できます。

```shell
$ xa '"abcde"[1..3]'
# bcd
```

# 文字列の置換

`STRING::replace(old: STRING | REGEX; new: STRING | (match: VALUE) -> STRING): STRING`

`STRING::replaceAll(old: STRING | REGEX; new: STRING | (match: VALUE) -> STRING): STRING`

`STRING::replaceFirst(old: STRING | REGEX; new: STRING | (match: VALUE) -> STRING): STRING`

`replace` `replaceAll` `replaceFirst` メソッドで文字列内の置換を行うことができます。

## 置換対象

各メソッドの置換対象は以下の通りです。

| メソッド           | 文字列の置換対象 | 正規表現の置換対象      |
|----------------|----------|----------------|
| `replace`      | すべての出現個所 | グローバルマッチフラグに従う |
| `replaceAll`   | すべての出現個所 | すべてのマッチ部分      |
| `replaceFirst` | 最初の出現個所  | 最初のマッチ部分       |

## 文字列による置換

`old` に文字列が渡された場合、その文字列と完全に一致する出現個所を置換します。

文字列版 `replace` メソッドは `replaceAll` メソッドと同じ動作をします。

```shell
$ xa '"-ab--ab-"::replace("ab"; "XX")'
# -XX--XX-

$ xa '"-ab--ab-"::replaceAll("ab"; "XX")'
# -XX--XX-

$ xa '"-ab--ab-"::replaceFirst("ab"; "XX")'
# -XX--ab-
```

## 正規表現による置換

`old` に正規表現が渡された場合、その正規表現にマッチしたすべての部分を置換します。

正規表現オブジェクトがグローバルでない場合、最初にマッチした部分のみが置換対象となります。

```shell
$ xa '"-ab--ab-"::replace(/[a-z]{2}/; "XX")'
# -XX--ab-

$ xa '"-ab--ab-"::replace(/[a-z]{2}/g; "XX")'
# -XX--XX-
```

---

`replaceAll` メソッドと `replaceFirst` メソッドは正規表現のグローバルマッチフラグを無視します。

```shell
$ xa '"-ab--ab-"::replaceAll(/[a-z]{2}/; "XX")'
# -XX--XX-

$ xa '"-ab--ab-"::replaceAll(/[a-z]{2}/g; "XX")'
# -XX--XX-

$ xa '"-ab--ab-"::replaceFirst(/[a-z]{2}/; "XX")'
# -XX--ab-

$ xa '"-ab--ab-"::replaceFirst(/[a-z]{2}/g; "XX")'
# -XX--ab-
```

## 関数への置換

`new` に関数が渡された場合、マッチした各部分に対してその関数が呼び出され、その戻り値で置換されます。

```shell
$ xa '"-ab--ab-"::replace("ab"; m -> m.0 * 2)'
# -abab--abab-

$ xa '"-ab--ab-"::replace(/[a-z]{2}/g; m -> m.0 * 2)'
# -abab--abab-
```

# 文字列ユーティリティ関数

## `UC` 大文字に変換

`UC(string: STRING): STRING`

`UC(string: STREAM<STRING>): STREAM<STRING>`

引数を文字列化したうえで、大文字に変換します。

ストリームを渡した場合は、各要素を大文字に変換するストリームを返します。

```shell
$ xa 'UC("Ab")'
# AB

$ xa '"Ab", "Cd" >> UC'
# AB
# CD
```

---

`string::UC()` で呼び出すことができる拡張関数版もあります。

```shell
$ xa '"Ab"::UC()'
# AB
```

## `LC` 小文字に変換

`LC(string: STRING): STRING`

`LC(string: STREAM<STRING>): STREAM<STRING>`

引数を文字列化したうえで、小文字に変換します。

その他の仕様は `UC` と共通です。

```shell
$ xa 'LC("Ab")'
# ab

$ xa '"Ab", "Cd" >> LC'
# ab
# cd
```

---

`string::LC()` で呼び出すことができる拡張関数版もあります。

```shell
$ xa '"Ab"::LC()'
# ab
```

## `RESOLVE` パス解決

`RESOLVE(dir: STRING; file: STRING): STRING`

2つの引数を文字列化したうえで、パスを結合して正規化します。

第1引数はディレクトリパス、第2引数はファイルパスまたは相対パスです。

この関数は、冗長なパス（`.` や `..` を含むパス）を正規化します。
ただし、シンボリックリンクは解決しません。

ディレクトリパスの末尾がスラッシュ `/` で終わるかどうかに関わらず、正しくパスを結合します。
これは、PWDがルートディレクトリ `/` の場合に特に重要です。

```shell
$ xa 'RESOLVE("/home/user"; "file.txt")'
# /home/user/file.txt

$ xa 'RESOLVE("/"; "file.txt")'
# /file.txt

$ xa 'RESOLVE("/home/user"; "../other/file.txt")'
# /home/other/file.txt
```

---

`dir::RESOLVE(file)` で呼び出すことができる拡張関数版もあります。

```shell
$ xa '"/home/user"::RESOLVE("file.txt")'
# /home/user/file.txt
```
