<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>範囲系演算子 - Xarpite</title>
    <meta name="description" content="An interpreted language for one-liners">
    <link rel="stylesheet" href="/xarpite/assets/css/style.css">
    <link rel="icon" type="image/svg+xml" href="/xarpite/assets/images/xarpite-icon.svg">
    <script src="/xarpite/assets/js/main.js" defer></script>
</head>
<body>
<div class="page-wrapper">
    <header class="site-header">
        <div class="container">
            <div class="header-content">
                <a href="/xarpite/" class="logo-link">
                    <img src="/xarpite/assets/images/xarpite-icon.svg" alt="Xarpite Icon" class="logo-icon">
                    <span class="logo-text">Xarpite</span>
                </a>
                <nav class="main-nav">
                    <a href="/xarpite/docs/ja/" class="nav-link">ドキュメント</a>
                    <a href="https://github.com/MirrgieRiana/xarpite" class="nav-link" target="_blank">GitHub</a>
                    <a href="https://mirrgieriana.github.io/xarpite/playground/" class="nav-link playground-link" target="_blank">Playground</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="content-wrapper">
                <aside class="sidebar">
                    
                    <nav class="doc-nav">
  <h3 class="nav-title">ドキュメント</h3>
  <ul class="nav-list">
    <li><a href="/xarpite/docs/ja/">トップ</a></li>
    <li><a href="/xarpite/docs/ja/syntax.html">文法</a></li>
    <li><a href="/xarpite/docs/ja/statement.html">文・式</a></li>
    <li><a href="/xarpite/docs/ja/whitespace.html">空白・コメント</a></li>
    <li><a href="/xarpite/docs/ja/variable.html">変数</a></li>
    <li><a href="/xarpite/docs/ja/number.html">数値</a></li>
    <li><a href="/xarpite/docs/ja/string.html">文字列</a></li>
    <li><a href="/xarpite/docs/ja/regex.html">正規表現</a></li>
    <li><a href="/xarpite/docs/ja/blob.html">BLOB</a></li>
    <li><a href="/xarpite/docs/ja/comparison.html">比較</a></li>
    <li><a href="/xarpite/docs/ja/boolean.html">論理値・条件分岐</a></li>
    <li><a href="/xarpite/docs/ja/control-structures.html">制御構文</a></li>
    <li><a href="/xarpite/docs/ja/jump.html">リターン・エラー処理</a></li>
    <li><a href="/xarpite/docs/ja/property.html">プロパティアクセス</a></li>
    <li><a href="/xarpite/docs/ja/array.html">配列</a></li>
    <li><a href="/xarpite/docs/ja/object.html">オブジェクト</a></li>
    <li><a href="/xarpite/docs/ja/length.html">長さ</a></li>
    <li><a href="/xarpite/docs/ja/function.html">関数</a></li>
    <li><a href="/xarpite/docs/ja/stream.html">ストリーム・代入・パイプ系演算子</a></li>
    <li><a href="/xarpite/docs/ja/builtin.html">組み込み定数・関数</a></li>
    <li><a href="/xarpite/docs/ja/data-conversion.html">データ変換系関数</a></li>
    <li><a href="/xarpite/docs/ja/samples.html">サンプル</a></li>
    <li><a href="/xarpite/docs/ja/cli.html">コマンドラインツール</a></li>
    <li><a href="/xarpite/docs/ja/js.html">JavaScript版</a></li>
    <li><a href="/xarpite/docs/ja/coroutine.html">コルーチン</a></li>
    <li><a href="/xarpite/docs/ja/json.html">JSON操作</a></li>
  </ul>
</nav>

                </aside>

                <article class="doc-content">
                    
                    
                        
                        
                        
                        
                            <div class="table-of-contents">
  <ul id="markdown-toc"><li><a href="#範囲系演算子">範囲系演算子</a><ul id="markdown-toc"><li><a href="#閉区間-start--end">閉区間 start .. end</a></li><li><a href="#半開区間-start--end">半開区間 start ~ end</a></li></ul></li><li><a href="#ストリーム結合系演算子">ストリーム結合系演算子</a><ul id="markdown-toc"><li><a href="#ストリームの結合-items-">ストリームの結合 items, ...</a></li></ul></li><li><a href="#ストリーム系演算子">ストリーム系演算子</a><ul id="markdown-toc"><li><a href="#ストリーム系演算子の簡単な紹介">ストリーム系演算子の簡単な紹介</a></li><li><a href="#結合優先度について">結合優先度について</a></li><li><a href="#配列の要素への代入代入系-arrayindex--value">配列の要素への代入（代入系） array(index) = value</a></li><li><a href="#エントリー演算子代入系-key-value">エントリー演算子（代入系） key: value</a></li><li><a href="#左実行パイプ代入系-function--value">左実行パイプ（代入系） function &amp;lt;&amp;lt; value</a></li><li><a href="#パイプパイプ系-stream--formula">パイプ（パイプ系） stream | formula</a></li><li><a href="#右実行パイプ実行パイプ系-value--function">右実行パイプ（実行パイプ系） value &amp;gt;&amp;gt; function</a></li><li><a href="#オブジェクトの継承-parententry-">オブジェクトの継承 parent{entry; ...}</a></li><li><a href="#オブジェクトの要素アクセス-objectkey">オブジェクトの要素アクセス object.key</a></li><li><a href="#null安全要素アクセス-objectkey">Null安全要素アクセス object?.key</a></li></ul></li><li><a href="#パイプと実行パイプのインデントのベストプラクティス">パイプと実行パイプのインデントのベストプラクティス</a><ul id="markdown-toc"><li><a href="#パイプの連鎖">パイプの連鎖</a></li><li><a href="#実行パイプによるパイプのインデントのリセット">実行パイプによるパイプのインデントのリセット</a></li></ul></li><li><a href="#ストリームのプロパティアクセス">ストリームのプロパティアクセス</a></li><li><a href="#ストリームの解決">ストリームの解決</a></li><li><a href="#ストリーム系関数">ストリーム系関数</a><ul id="markdown-toc"><li><a href="#pipe-読み取り位置を記憶するストリームを生成する">PIPE: 読み取り位置を記憶するストリームを生成する</a></li></ul></li></ul>
</div>


<h1 id="範囲系演算子">範囲系演算子</h1>

<h2 id="閉区間-start--end">閉区間 <code class="language-plaintext highlighter-rouge">start .. end</code></h2>

<p>閉区間演算子は、左辺から右辺までの整数の範囲のストリームを生成します。</p>

<p>end自身はストリームに含まれます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1 .. 3'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
</code></pre></div></div>

<hr />

<p>左辺が右辺よりも大きい場合、カウントダウンを行います。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'3 .. 1'</span>
<span class="c"># 3</span>
<span class="c"># 2</span>
<span class="c"># 1</span>
</code></pre></div></div>

<h2 id="半開区間-start--end">半開区間 <code class="language-plaintext highlighter-rouge">start ~ end</code></h2>

<p>半開区間演算子は、左辺から右辺の1つ手前までの整数の範囲のストリームを生成します。</p>

<p>end自身はストリームに含まれません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1 ~ 3'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
</code></pre></div></div>

<hr />

<p>半開区間演算子は、閉区間演算子とは異なり、右辺が左辺よりも大きい場合、空のストリームを生成します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'[3 ~ 1]'</span>
<span class="c"># []</span>
</code></pre></div></div>

<h1 id="ストリーム結合系演算子">ストリーム結合系演算子</h1>

<h2 id="ストリームの結合-items-">ストリームの結合 <code class="language-plaintext highlighter-rouge">items, ...</code></h2>

<p>演算子 <code class="language-plaintext highlighter-rouge">,</code> は、左右の要素またはストリームを結合したストリームを生成します。</p>

<p>Xarpiteでは、ラムダ演算子の左辺のような特殊な場所でない限り、 <code class="language-plaintext highlighter-rouge">,</code> は引数や配列要素等の区切りではなくストリーム結合演算子として解釈されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1, 2 .. 4, 5'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
<span class="c"># 4</span>
<span class="c"># 5</span>
</code></pre></div></div>

<hr />

<p>ストリーム結合演算子は余計に多く書いても無視されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">', , 1, , , , 2, , '</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
</code></pre></div></div>

<hr />

<p>ストリーム結合演算子のみを記述することができ、その場合は空ストリームを生成します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'[,]'</span>
<span class="c"># []</span>
</code></pre></div></div>

<hr />

<p>xaコマンドはデフォルトの挙動で与えられたソースコードの戻り値を出力しますが、空のストリームに対しては何も出力しないため、xaコマンドの出力を抑制するのに使われることもあります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'"何らかの副作用を伴う処理"; ,'</span>
</code></pre></div></div>

<h1 id="ストリーム系演算子">ストリーム系演算子</h1>

<p>ストリーム系演算子は、ストリームの加工や代入などを行う演算子です。</p>

<h2 id="ストリーム系演算子の簡単な紹介">ストリーム系演算子の簡単な紹介</h2>

<p>結合優先度についての解説のため、ストリーム系に属する演算子を軽く紹介します。</p>

<hr />

<p>パイプ <code class="language-plaintext highlighter-rouge">stream | argument =&gt; formula</code> は、 <code class="language-plaintext highlighter-rouge">stream</code> の各要素について <code class="language-plaintext highlighter-rouge">formula</code> を適用したストリームを得ます。</p>

<p><code class="language-plaintext highlighter-rouge">formula</code> 内では、 <code class="language-plaintext highlighter-rouge">argument</code> でその要素を参照できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1, 2, 3 | x =&gt; x * 10'</span>
<span class="c"># 10</span>
<span class="c"># 20</span>
<span class="c"># 30</span>
</code></pre></div></div>

<hr />

<p>実行パイプ <code class="language-plaintext highlighter-rouge">value &gt;&gt; function</code> は、 <code class="language-plaintext highlighter-rouge">function</code> に <code class="language-plaintext highlighter-rouge">value</code> を渡して実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1, 2, 3 &gt;&gt; REVERSE'</span>
<span class="c"># 3</span>
<span class="c"># 2</span>
<span class="c"># 1</span>
</code></pre></div></div>

<hr />

<p>変数宣言 <code class="language-plaintext highlighter-rouge">variable := value</code> は、変数 <code class="language-plaintext highlighter-rouge">variable</code> を宣言しつつ、その値を <code class="language-plaintext highlighter-rouge">value</code> で初期化します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  x := 123
  x
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<hr />

<p>代入 <code class="language-plaintext highlighter-rouge">variable = value</code> は、変数 <code class="language-plaintext highlighter-rouge">variable</code> に <code class="language-plaintext highlighter-rouge">value</code> を代入します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  x := 123
  x = 456
  x
'</span>
<span class="c"># 456</span>
</code></pre></div></div>

<h2 id="結合優先度について">結合優先度について</h2>

<p>ストリーム系演算子は、実用上の理由から、以下の文法で表される複雑な結合規則を持っています。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ストリームノード :=
    ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード  ストリーム後方付加部*

ストリーム後方付加部 :=
    パイプ演算子  パイプ右辺
  / 実行パイプ演算子  実行パイプ右辺

実行パイプ右辺 :=
    ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード

パイプ右辺 :=
    ストリーム結合ノード  パイプ系演算子  パイプ右辺
  / ストリーム結合ノード  代入系演算子  ストリームノード
  / ストリーム結合ノード
</code></pre></div></div>

<p>以下では、ストリーム系演算子の文法を例を用いて解説します。</p>

<hr />

<p>パイプ系演算子は、原則として右優先結合です。</p>

<p>このため、前段の変数を後段から参照することができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'10, 20 | x =&gt; 3, 4 | y =&gt; x + y'</span>
<span class="c"># 13</span>
<span class="c"># 14</span>
<span class="c"># 23</span>
<span class="c"># 24</span>

<span class="nv">$ </span>xa <span class="s1">'10, 20 | x =&gt; (3, 4 | y =&gt; x + y)'</span>
<span class="c"># 13</span>
<span class="c"># 14</span>
<span class="c"># 23</span>
<span class="c"># 24</span>
</code></pre></div></div>

<hr />

<p>実行パイプ系演算子は、左側にあるパイプ系・実行パイプ系演算子をまとめて取ります。</p>

<p>これにより、様々に加工したストリームの全体を関数に入力することができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'10, 20 | x =&gt; 3, 4 | y =&gt; x + y &gt;&gt; JOIN["-"]'</span>
<span class="c"># 13-14-23-24</span>

<span class="nv">$ </span>xa <span class="s1">'(10, 20 | x =&gt; 3, 4 | y =&gt; x + y) &gt;&gt; JOIN["-"]'</span>
<span class="c"># 13-14-23-24</span>
</code></pre></div></div>

<p>実行パイプ系演算子は他の実行パイプ系演算子も左辺にまとめて取ります。</p>

<p>また、実行パイプ系演算子による結果を、さらに別のパイプ系演算子で加工出来ます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1 .. 3 | _ * 10 &gt;&gt; REVERSE | _ + 5 &gt;&gt; JOIN["-"]'</span>
<span class="c"># 35-25-15</span>

<span class="nv">$ </span>xa <span class="s1">'((1 .. 3 | _ * 10) &gt;&gt; REVERSE | _ + 5) &gt;&gt; JOIN["-"]'</span>
<span class="c"># 35-25-15</span>
</code></pre></div></div>

<hr />

<p>代入系演算子は、右辺を左辺から分離します。</p>

<p>代入系演算子の右辺にある実行パイプ系演算子は、代入系演算子の左辺には影響を及ぼしません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  pow2_joiner := stream -&gt; stream | x =&gt; x * x &gt;&gt; JOIN["-"]
  pow2_joiner(1, 2, 3)
'</span>
<span class="c"># 1-4-9</span>
</code></pre></div></div>

<p>以下では、関数 <code class="language-plaintext highlighter-rouge">setter</code> を呼び出すと、与えた数値に36を足して平方根を取った値を変数 <code class="language-plaintext highlighter-rouge">variable</code> に代入します。</p>

<p><code class="language-plaintext highlighter-rouge">SQRT</code> の左にある <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> は、その左の <code class="language-plaintext highlighter-rouge">=</code> の手前までを左辺に取ります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  variable := NULL
  setter := x -&gt; x + 36 | x2 =&gt; variable = x2 &gt;&gt; SQRT
  setter(64)
  variable
'</span>
<span class="c"># 10.0</span>
</code></pre></div></div>

<h2 id="配列の要素への代入代入系-arrayindex--value">配列の要素への代入（代入系） <code class="language-plaintext highlighter-rouge">array(index) = value</code></h2>

<p>左辺が配列の要素の参照であった場合、その要素に右辺の値を代入します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  array := [1, 2, 3]
  OUT &lt;&lt; array
  array(1) = 4
  OUT &lt;&lt; array
'</span>
<span class="c"># [1;2;3]</span>
<span class="c"># [1;4;3]</span>
</code></pre></div></div>

<h2 id="エントリー演算子代入系-key-value">エントリー演算子（代入系） <code class="language-plaintext highlighter-rouge">key: value</code></h2>

<p>エントリー演算子は、両辺を要素とする2要素の配列を生成する演算子です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'a: 1'</span>
<span class="c"># [a;1]</span>
</code></pre></div></div>

<hr />

<p>左辺が識別子の場合、同名の変数があっても、変数を参照するのではなく文字列として扱います。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  a := "b"
  a: 1
'</span>
<span class="c"># [a;1]</span>
</code></pre></div></div>

<hr />

<p>左辺で変数を参照したい場合は、括弧で囲むことで文字列として扱われることを回避できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  a := "b"
  (a): 1
'</span>
<span class="c"># [b;1]</span>
</code></pre></div></div>

<hr />

<p>エントリー演算子は配列リテラルとは異なり、ストリームを展開せず、常に2要素の配列を生成します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'["key"; 1 .. 3]'</span>
<span class="c"># [key;1;2;3]</span>

<span class="nv">$ </span>xa <span class="s1">'key: 1 .. 3'</span>
<span class="c"># [key;123]</span>
</code></pre></div></div>

<hr />

<p>この演算子はオブジェクトを生成する際に有用です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  {
    a: 1
    b: 2
  }
'</span>
<span class="c"># {a:1;b:2}</span>
</code></pre></div></div>

<h2 id="左実行パイプ代入系-function--value">左実行パイプ（代入系） <code class="language-plaintext highlighter-rouge">function &lt;&lt; value</code></h2>

<p>左実行パイプは、右辺の値を左辺の関数の第1引数に指定して呼び出します。</p>

<p>右実行パイプの左右が逆のバージョンですが、結合優先度が代入系扱いです。</p>

<p>使い方によっては可読性に貢献する可能性を秘めています。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  OUT &lt;&lt; "Hello, World"
'</span>
<span class="c"># Hello, World</span>
</code></pre></div></div>

<h2 id="パイプパイプ系-stream--formula">パイプ（パイプ系） <code class="language-plaintext highlighter-rouge">stream | formula</code></h2>

<p>パイプ演算子 <code class="language-plaintext highlighter-rouge">|</code> は、左辺のストリームの各値に対して右辺を評価し、そのフラットなストリームを返します。</p>

<p>右辺では、変数 <code class="language-plaintext highlighter-rouge">_</code> によって左辺の各要素の値を得ることができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1 .. 3 | _, _ * 10'</span>
<span class="c"># 1</span>
<span class="c"># 10</span>
<span class="c"># 2</span>
<span class="c"># 20</span>
<span class="c"># 3</span>
<span class="c"># 30</span>
</code></pre></div></div>

<hr />

<p>左辺がストリームでない場合、右辺の返却値はストリームで改めてラッピングされることなく、そのままの型で返されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'(5 | _ * 10) + 7'</span>
<span class="c"># 57</span>
</code></pre></div></div>

<hr />

<p>右辺に渡される変数は <code class="language-plaintext highlighter-rouge">=&gt;</code> によって変更できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'5 | x =&gt; x * 10'</span>
<span class="c"># 50</span>
</code></pre></div></div>

<hr />

<p>右辺の引数を <code class="language-plaintext highlighter-rouge">index, value =&gt; formula</code> の形式にすることで、左辺のストリームの各要素のインデックスと値を取得できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'"a", "b", "c" | i, v =&gt; "$i: $v"'</span>
<span class="c"># 0: a</span>
<span class="c"># 1: b</span>
<span class="c"># 2: c</span>
</code></pre></div></div>

<hr />

<p>パイプ演算子をループ構文のように使うこともできます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  x := 0
  1 .. 10 | (
    x = x + _
  )
  x
'</span>
<span class="c"># 55</span>
</code></pre></div></div>

<hr />

<p>ループ変数は右辺が評価されるごとに独立して作られます。</p>

<p>このため、ループの進行によって変数の内容が変わったり、変数への代入が異なる評価の間で影響し合うことはありません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  accessors := [1 .. 4 | value =&gt; {
    set: _ -&gt; value = _
    get: , -&gt; value
  }]
  accessors.2.set() = 99
  accessors().get()
'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 99</span>
<span class="c"># 4</span>
</code></pre></div></div>

<h2 id="右実行パイプ実行パイプ系-value--function">右実行パイプ（実行パイプ系） <code class="language-plaintext highlighter-rouge">value &gt;&gt; function</code></h2>

<p>右実行パイプは、左辺の値を右辺の関数の第1引数に指定して呼び出します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1 .. 3 &gt;&gt; JOIN["-"]'</span>
<span class="c"># 1-2-3</span>
</code></pre></div></div>

<hr />

<p>この演算子はストリームを扱う関数の実行に便利です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'"1+2+3" &gt;&gt; SPLIT["+"] | +_ * 2 &gt;&gt; JOIN["-"]'</span>
<span class="c"># 2-4-6</span>
</code></pre></div></div>

<h2 id="オブジェクトの継承-parententry-">オブジェクトの継承 <code class="language-plaintext highlighter-rouge">parent{entry; ...}</code></h2>

<p>オブジェクトに <code class="language-plaintext highlighter-rouge">{</code> <code class="language-plaintext highlighter-rouge">}</code> を後置すると、そのオブジェクトを親とする子オブジェクトを生成します。</p>

<p>オブジェクトの継承は主にメソッドの検索に使われ、エントリーの継承は行われません。</p>

<p>オブジェクトの生成方法はオブジェクトリテラルと共通です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'{a: 1; m: this -&gt; 3}{b: 2}'</span>
<span class="c"># {b:2}</span>

<span class="nv">$ </span>xa <span class="s1">'{a: 1; m: this -&gt; 3}{b: 2}.a'</span>
<span class="c"># NULL</span>

<span class="nv">$ </span>xa <span class="s1">'{a: 1; m: this -&gt; 3}{b: 2}::m()'</span>
<span class="c"># 3</span>
</code></pre></div></div>

<h2 id="オブジェクトの要素アクセス-objectkey">オブジェクトの要素アクセス <code class="language-plaintext highlighter-rouge">object.key</code></h2>

<p><code class="language-plaintext highlighter-rouge">.</code> 演算子でオブジェクトの要素にアクセスできます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'{x: 123}.x'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<hr />

<p>オブジェクトが親オブジェクトを持つ場合でも、親オブジェクトの要素は継承されません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'{x: 123}{}.x'</span>
<span class="c"># NULL</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">.</code> の右辺に括弧を置くことで、任意の式によって参照できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  obj := {item1: 123; item2: 456}
  index := 2
  obj.("item$index")
'</span>
<span class="c"># 456</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">.</code> は、右辺が識別子の場合、それを変数ではなくキーとして解釈する性質があります。</p>

<p>したがって、括弧の有無によって参照するエントリーに違いが現れます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  key := "item1"
  obj := {key: 123; item1: 456}
  [obj.key; obj.(key)]
'</span>
<span class="c"># [123;456]</span>
</code></pre></div></div>

<hr />

<p>キーは自動的に文字列化されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'{1: 123}.1'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="null安全要素アクセス-objectkey">Null安全要素アクセス <code class="language-plaintext highlighter-rouge">object?.key</code></h2>

<p><code class="language-plaintext highlighter-rouge">?.</code> 演算子は左辺が <code class="language-plaintext highlighter-rouge">NULL</code> の場合に、要素の取得を試みる代わりに <code class="language-plaintext highlighter-rouge">NULL</code> を返します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'{x: 1}, NULL, {x: 3} | _?.x'</span>
<span class="c"># 1</span>
<span class="c"># NULL</span>
<span class="c"># 3</span>
</code></pre></div></div>

<h1 id="パイプと実行パイプのインデントのベストプラクティス">パイプと実行パイプのインデントのベストプラクティス</h1>

<p>パイプ演算子 <code class="language-plaintext highlighter-rouge">|</code> と実行パイプ演算子 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> はその左右どちらでも改行でき、ある程度自由に記述できます。</p>

<p>ここではベストプラクティスとして推奨されるインデントスタイルを示します。</p>

<h2 id="パイプの連鎖">パイプの連鎖</h2>

<p><code class="language-plaintext highlighter-rouge">|</code> の位置で改行する場合、その直後もしくはそれに続く <code class="language-plaintext highlighter-rouge">=&gt;</code> の直後で改行し、右辺をインデントをします。</p>

<p>こうすることで、行頭が常に式の先頭になり、一貫します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a |
  b
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a | b =&gt;
  c
</code></pre></div></div>

<p>連鎖する場合も同様です。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a | b =&gt;
  c |
    d | e =&gt;
      f
</code></pre></div></div>

<h2 id="実行パイプによるパイプのインデントのリセット">実行パイプによるパイプのインデントのリセット</h2>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code> の位置で改行する場合、その直前で改行しつつ、それまでの <code class="language-plaintext highlighter-rouge">|</code> 演算子によるインデントをすべて解除します。</p>

<p>こうすることで、 <code class="language-plaintext highlighter-rouge">|</code> によって宣言されたループ変数のスコープが <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> の直前で切れたことが明瞭になります。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a |
  b | c =&gt;
    d
&gt;&gt; e
&gt;&gt; f
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code> の後に <code class="language-plaintext highlighter-rouge">|</code> が続く場合、 <code class="language-plaintext highlighter-rouge">|</code> の前で改行します。</p>

<p>これにより、 <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> のある行のスタイルが一貫します。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a | b =&gt;
  c
&gt;&gt; b
&gt;&gt; e
| f =&gt;
  g |
    h
&gt;&gt; i
</code></pre></div></div>

<h1 id="ストリームのプロパティアクセス">ストリームのプロパティアクセス</h1>

<p>ストリームに対してプロパティアクセスをすると、各要素のプロパティアクセスの結果を結合したストリームを返します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  (
    {a: 1},
    {a: 2 .. 4},
  ).a
'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
<span class="c"># 4</span>
</code></pre></div></div>

<h1 id="ストリームの解決">ストリームの解決</h1>

<p>戻り値としてストリームを返却する演算子や関数は、ストリームの副作用の保証のためにストリームの解決を行う場合があります。</p>

<p>ストリームの解決とは、本来のストリームの代わりに、その要素列を再現するキャッシュのストリームを返すことをいいます。</p>

<p>本来のストリームは解決時に丁度1回だけ全体が評価され、その際に副作用も丁度1回だけ発生します。</p>

<hr />

<p>この動作は、ストリームという値が本質的に遅延評価される命令の塊であることに起因します。</p>

<p>例えば、以下の例では <code class="language-plaintext highlighter-rouge">stream</code> の実際のイテレーションの開始はプログラム全体の結果を実際に出力するまで遅延されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  array := [1, 2, 3]
  stream := array()
  array::push &lt;&lt; 4, 5
  stream
'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
<span class="c"># 4</span>
<span class="c"># 5</span>
</code></pre></div></div>

<p>この性質は、副作用の効果を期待するプログラムでは邪魔になることがあります。</p>

<p>以下の例では、パイプ演算子を使って配列に要素を追加することを期待していますが、2番目の例は副作用が発生しません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  array := [1, 2, 3]
  4, 5 | *array::push
  array
'</span>
<span class="c"># [1;2;3;4;5]</span>

<span class="nv">$ </span>xa <span class="s1">'
  array := [1, 2, 3]
  dummy := 4, 5 | *array::push
  array
'</span>
<span class="c"># [1;2;3]</span>
</code></pre></div></div>

<p>ストリームの解決を行い、副作用をその場で発生させる簡単な方法は、複文によって文（runner）として実行させることです。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  array := [1, 2, 3]
  dummy := (4, 5 | *array::push;)
  array
'</span>
<span class="c"># [1;2;3;4;5]</span>
</code></pre></div></div>

<hr />

<p>キャッシュ用の配列の保持は、解決されたストリームの結果がどこにも使われない場合、メモリ節約のために省略される場合があります。</p>

<hr />

<p>無限ストリームの解決を試みた場合、エラーやリターン演算子等で途中離脱しない限り、プログラムはその場所で無限ループに陥ります。</p>

<p>その結果、プログラムが進行しなくなったり、メモリ不足でクラッシュしたりする可能性があります。</p>

<p>例えば、 <code class="language-plaintext highlighter-rouge">LOOP !? "Error"</code> という式は無限ループに陥ります。</p>

<p>これはキャッチ演算子 <code class="language-plaintext highlighter-rouge">!?</code> が <code class="language-plaintext highlighter-rouge">LOOP</code> に含まれる無限のNULLのどこかで何かがスローされないかチェックしようとするためです。</p>

<p>ストリームの解決を避けるには、ストリームそのものの代わりにストリームを返す関数の状態でやりとりする方法があります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  getStream := (() -&gt; LOOP | i, _ =&gt; i) !? "Error"
  getStream() &gt;&gt; TAKE[3]
'</span>
<span class="c"># 0</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
</code></pre></div></div>

<h1 id="ストリーム系関数">ストリーム系関数</h1>

<h2 id="pipe-読み取り位置を記憶するストリームを生成する"><code class="language-plaintext highlighter-rouge">PIPE</code>: 読み取り位置を記憶するストリームを生成する</h2>

<p><code class="language-plaintext highlighter-rouge">&lt;T&gt; PIPE(stream: STREAM&lt;T&gt;): STREAM&lt;T&gt;</code></p>

<p><code class="language-plaintext highlighter-rouge">stream</code> のイテレーションを保持し、イテレート時に保持した位置から再開するストリームを生成します。</p>

<hr />

<p>このような性質を持つストリームは、便宜上「パイプ」と呼ばれます。</p>

<p>CLI上で標準入力を受け付ける <code class="language-plaintext highlighter-rouge">IN</code> などもパイプに相当します。</p>

<p>パイプは <code class="language-plaintext highlighter-rouge">FIRST</code> や <code class="language-plaintext highlighter-rouge">TAKE</code> などのストリームを中途半端に消費する関数と組み合わせることで真価を発揮します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  pipe := PIPE(1 .. 10)
  OUT &lt;&lt; "First: " &amp; FIRST(pipe)
  OUT &lt;&lt; "Next 3 items: " &amp; [pipe &gt;&gt; TAKE[3]]
  OUT &lt;&lt; "Next: " &amp; FIRST(pipe)
'</span>
<span class="c"># First: 1</span>
<span class="c"># Next 3 items: [2;3;4]</span>
<span class="c"># Next: 5</span>
</code></pre></div></div>

<hr />

<p>読み切ったパイプは空ストリームになります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  pipe := PIPE(1 .. 10)
  OUT &lt;&lt; [pipe]
  OUT &lt;&lt; [pipe]
'</span>
<span class="c"># [1;2;3;4;5;6;7;8;9;10]</span>
<span class="c"># []</span>
</code></pre></div></div>

<hr />

<p>性質上、返されるストリームを通じて、 <code class="language-plaintext highlighter-rouge">stream</code> は高々1度のみイテレートされます。</p>

<p>これにより <code class="language-plaintext highlighter-rouge">stream</code> が引き起こす副作用も複数回発生することはありません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  array := []
  pipe := PIPE(
    1 .. 3 | (
      array::push &lt;&lt; _
    )
  )

  pipe
  pipe
  pipe

  array
'</span>
<span class="c"># [1;2;3]</span>
</code></pre></div></div>

<hr />

<p>ただし、 <code class="language-plaintext highlighter-rouge">PIPE</code> は <code class="language-plaintext highlighter-rouge">stream</code> の要素をバッファリングする可能性があり、副作用が意図しないタイミングで発生する可能性があります。</p>

<p>副作用のタイミングを制御するには、副作用のある処理を関数にし、パイプから取り出した側でそれを実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  tasks := PIPE(
    1 .. 10 | , -&gt; (
      OUT &lt;&lt; "Task $_"
    )
  )

  OUT &lt;&lt; "Execute 1 task"
  FIRST(tasks) | _()
  OUT &lt;&lt; "Execute 3 tasks"
  TAKE(3; tasks) | _()
  OUT &lt;&lt; "Execute 1 task"
  FIRST(tasks) | _()
'</span>
<span class="c"># Execute 1 task</span>
<span class="c"># Task 1</span>
<span class="c"># Execute 3 tasks</span>
<span class="c"># Task 2</span>
<span class="c"># Task 3</span>
<span class="c"># Task 4</span>
<span class="c"># Execute 1 task</span>
<span class="c"># Task 5</span>
</code></pre></div></div>

<hr />

<p>パイプは遅延評価であり、返されたストリームが消費されない場合、 <code class="language-plaintext highlighter-rouge">stream</code> のイテレーションは開始されません。</p>

<p>したがって、副作用も発生しません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  array := []
  pipe := PIPE(
    1 .. 10000 | (
      array::push &lt;&lt; _
    )
  )
  array
'</span>
<span class="c"># []</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">stream</code> は無限ストリームであってもかまいません。</p>

<p>パイプが最後まで読み切られなくても、 <code class="language-plaintext highlighter-rouge">stream</code> をイテレートするためのリソースはプログラムの終了時に自動的に解放されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  pipe := PIPE(LOOP | i, _ =&gt; i)
  OUT &lt;&lt; [pipe &gt;&gt; TAKE[10]]
  "Finished"
'</span>
<span class="c"># [0;1;2;3;4;5;6;7;8;9]</span>
<span class="c"># Finished</span>
</code></pre></div></div>

                        
                    
                </article>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <p class="footer-text">
                    &copy; 2024-2025 <a href="https://github.com/MirrgieRiana" target="_blank" class="footer-link">MirrgieRiana</a>.
                    <a href="https://github.com/MirrgieRiana/xarpite" target="_blank" class="footer-link">GitHub</a>
                </p>
            </div>
        </div>
    </footer>
</div>
</body>
</html>
