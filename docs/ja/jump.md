---
title: "ラベルとリターン"
---

# ラベルとリターン

式の要素にラベルを付けて、そのラベルへ明示的に値を返しつつ、処理を早期に脱出できます。

## 簡単な例

`formula !: label` で式 `formula` に対してラベルを付与できます。

`formula` 内では、リターン演算子 `label !! value` でそのラベルに対して値を返すことができます。

```shell
$ xa '
  (
    label !! 10
    20
  ) !: label
'
# 10
```

---

ラベルはラベルを参照する個所でのみ有効で、変数のように値を読み書きすることはできません。

## ループからの脱出

リターンはループからの途中脱出にも利用できます。

以下の例では、1から100までの整数を順番にループしつつ、2でも3でも5でも割り切れる数を探します。

```shell
$ xa '
  (
    1 .. 100 | (
      (_ % 2 == 0 && _ % 3 == 0 && _ % 5 == 0) && found !! _
    )
    NULL
  ) !: found
'
# 30
```

## ラムダ式の内側からのリターン

関数に渡すラムダ式の内側から、外側のラベルに対してリターンすることもできます。

```shell
$ xa '
  for_each := array, block -> array() | *block
  (
    array := [1 .. 100]
    for_each[array] ( _ =>
      (_ % 2 == 0 && _ % 3 == 0 && _ % 5 == 0) && found !! _
    )
    NULL
  ) !: found
'
# 30
```

## ストリームの副作用

ラベルの `formula` の戻り値がストリームである場合、必ずその場で1度だけ評価され、副作用も1度だけ生じます。

```shell
$ xa '
  count := 0
  stream := (
    1 .. 3 | (
      count = count + 1
      count
    ) 
  ) !: break
  [stream], [stream], [stream], count
'
# [1;2;3]
# [1;2;3]
# [1;2;3]
# 3
```

---

これはラベルの戻り値であるストリームが1度も評価されない場合も同様です。

```shell
$ xa '
  count := 0
  stream := (
    1 .. 3 | (
      count = count + 1
      count
    ) 
  ) !: break
  count
'
# 3
```

---

この動作の実現のため、式（getter）であるラベルは `formula` の戻り値であるストリームの要素列を配列にキャッシュします。

この処理はラベルを文（runner）として実行することで抑制でき、メモリを節約できます。

```shell
$ xa '
  (
    1 .. 1000 | (
      [1 .. 1000]
    ) 
  ) !: break;
'
# NULL
```

## リターン値の省略

リターン演算子は `label !!` のように `value` 節を省略して書くこともできます。

この場合、 `NULL` が返されます。

```shell
$ xa '
  (
    label !!
    20
  ) !: label
'
# NULL
```

## リターン演算子の結合優先度

リターン演算子は特殊な前置演算子として扱われており、 `value` 節にはラベル演算子 `!:` よりも結合優先度の高い任意の式が来れます。

具体的には、 `value` 節には比較演算子までの式（ `>`, `<`, `==` など）を含めることができますが、 `!:`, `&&`, `||`, `!?`, `?:`, `,` などは含めることができません。

以下の例では `value` 節が文字列結合演算子を直接含んでいます。

```shell
$ xa '
  (
    value := 10
    value > 5 && result !! value & " is Larger than 5"
    value & " is Not Larger than 5"
  ) !: result
'
# 10 is Larger than 5
```

一方、ラベル構文と共起した場合はリターン演算子は外側のラベル構文によるラベルを参照できます。

```shell
$ xa '
  result !! "123" !: result
'
# 123
```

## ラベル演算子の結合優先度

ラベル演算子 `!:` は比較演算子 `>`, `<`, `==` などと同じレベルの結合優先度を持ちます。

これにより、ラベルは比較的狭い範囲を捕捉するようになります。例えば、 `a && b !: label` は `a && (b !: label)` と解釈され、 `b` にのみラベルが付きます。

# エラー処理

## スロー

Xarpiteでは、エラーのスローを `!! error` 演算子で行います。

スローする値はどのようなタイプの値であっても構いません。

スローした値は、キャッチした際に渡されます。

```shell
$ xa '!! "12345" !? (e => "Error ($e)")'
# Error (12345)
```

### スロー値の省略

スロー演算子は `!!` のように `error` 節を省略して書くこともできます。

この場合、 `NULL` がスローされます。

```shell
$ xa '!! !? (e => "Error ($e)")'
# Error (NULL)
```

### スロー演算子の結合優先度

スロー演算子もリターン演算子 `label !! value` と同様の結合規則を持ち、右辺にはラベル演算子 `!:` よりも結合優先度の高い任意の式が来れます。

具体的には、 `error` 節には比較演算子までの式を含めることができますが、 `!:`, `&&`, `||`, `!?`, `?:`, `,` などは含めることができません。

```shell
$ xa '
  (
    value := 10
    value > 5 && !! value & " is Larger than 5"
    value & " is Not Larger than 5"
  ) !? (e => e)
'
# 10 is Larger than 5
```

```shell
$ xa '
  !! "123" !? (e => e)
'
# 123
```

## トライキャッチ演算子

トライキャッチ演算子 `try !? catch` は、左辺で値がスローされなかった場合は左辺を、スローされた場合は右辺を返す演算子です。

スローされる値は、どのようなタイプの値である可能性もあります。

```shell
$ xa '"OK" !? "Failed"'
# OK

$ xa '!!"Error" !? "Failed"'
# Failed
```

### スローされた値の受け取り

`try !? (error => catch)` により、スローされた値を受け取ることができます。

```shell
$ xa '!!12345 !? (e => "Error: #$e")'
# Error: #12345
```

### ストリームの解決

トライキャッチ演算子 `!?` の左辺の戻り値がストリームである場合、その評価は必ず1度だけ行われ、副作用も1度だけ生じます。

```shell
$ xa '
  count := 0
  stream := (
    1 .. 3 | (
      count = count + 1
      count
    ) 
  ) !? "error"
  [stream], [stream], [stream], count
'
# [1;2;3]
# [1;2;3]
# [1;2;3]
# 3
```

---

これはトライキャッチ演算子の戻り値であるストリームが1度も評価されない場合も同様です。

```shell
$ xa '
  count := 0
  stream := (
    1 .. 3 | (
      count = count + 1
      count
    ) 
  ) !? "error"
  count
'
# 3
```

### 文レベルのトライキャッチ演算子

キャッチ演算子は式レベルとしても文レベルとしても機能します。

文レベルの位置に書かれたキャッチ演算子は、両辺とも文として解釈しようとします。

文レベルでも、左辺のストリームは1度だけ消費され、副作用も1度だけ生じます。

```shell
$ xa '
  count := 0
  (1 .. 3 | (count = count + 1; count)) !? "error";
  count
'
# 3
```

この性質は、ストリームの戻り値を持つ文を書いた場合に違いが現れる場合があります。

### トライキャッチ演算子の結合優先度

トライキャッチ演算子 `!?` はエルビス演算子 `?:` や三項演算子 `? :` とほぼ同じレベルの結合優先度を持ちます（わずかに高い）。

これにより、キャッチの対象範囲が比較的狭くなり、メソッドチェーンのような使い方がしやすくなります。例えば、 `f() !? else` のように関数呼び出しの結果のみをキャッチすることが自然に表現できます。

全体をキャッチしたい場合は、括弧で囲う必要があります。例: `(複雑な式) !? else`
