<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>関数 - Xarpite</title>
    <meta name="description" content="An interpreted language for one-liners">
    <link rel="stylesheet" href="/xarpite/assets/css/style.css">
    <link rel="icon" type="image/svg+xml" href="/xarpite/assets/images/xarpite-icon.svg">
    <script src="/xarpite/assets/js/main.js" defer></script>
</head>
<body>
<div class="page-wrapper">
    <header class="site-header">
        <div class="container">
            <div class="header-content">
                <a href="/xarpite/" class="logo-link">
                    <img src="/xarpite/assets/images/xarpite-icon.svg" alt="Xarpite Icon" class="logo-icon">
                    <span class="logo-text">Xarpite</span>
                </a>
                <nav class="main-nav">
                    <a href="/xarpite/docs/ja/" class="nav-link">ドキュメント</a>
                    <a href="https://github.com/MirrgieRiana/xarpite" class="nav-link" target="_blank">GitHub</a>
                    <a href="https://mirrgieriana.github.io/xarpite/playground/" class="nav-link playground-link" target="_blank">Playground</a>
                </nav>
            </div>
        </div>
    </header>

    <main class="main-content">
        <div class="container">
            <div class="content-wrapper">
                <aside class="sidebar">
                    
                    <nav class="doc-nav">
  <h3 class="nav-title">ドキュメント</h3>
  <ul class="nav-list">
    <li><a href="/xarpite/docs/ja/">トップ</a></li>
    <li><a href="/xarpite/docs/ja/syntax.html">文法</a></li>
    <li><a href="/xarpite/docs/ja/statement.html">文・式</a></li>
    <li><a href="/xarpite/docs/ja/whitespace.html">空白・コメント</a></li>
    <li><a href="/xarpite/docs/ja/variable.html">変数</a></li>
    <li><a href="/xarpite/docs/ja/number.html">数値</a></li>
    <li><a href="/xarpite/docs/ja/string.html">文字列</a></li>
    <li><a href="/xarpite/docs/ja/regex.html">正規表現</a></li>
    <li><a href="/xarpite/docs/ja/blob.html">BLOB</a></li>
    <li><a href="/xarpite/docs/ja/comparison.html">比較</a></li>
    <li><a href="/xarpite/docs/ja/boolean.html">論理値・条件分岐</a></li>
    <li><a href="/xarpite/docs/ja/control-structures.html">制御構文</a></li>
    <li><a href="/xarpite/docs/ja/jump.html">リターン・エラー処理</a></li>
    <li><a href="/xarpite/docs/ja/property.html">プロパティアクセス</a></li>
    <li><a href="/xarpite/docs/ja/array.html">配列</a></li>
    <li><a href="/xarpite/docs/ja/object.html">オブジェクト</a></li>
    <li><a href="/xarpite/docs/ja/length.html">長さ</a></li>
    <li><a href="/xarpite/docs/ja/function.html">関数</a></li>
    <li><a href="/xarpite/docs/ja/stream.html">ストリーム・代入・パイプ系演算子</a></li>
    <li><a href="/xarpite/docs/ja/builtin.html">組み込み定数・関数</a></li>
    <li><a href="/xarpite/docs/ja/data-conversion.html">データ変換系関数</a></li>
    <li><a href="/xarpite/docs/ja/samples.html">サンプル</a></li>
    <li><a href="/xarpite/docs/ja/cli.html">コマンドラインツール</a></li>
    <li><a href="/xarpite/docs/ja/js.html">JavaScript版</a></li>
    <li><a href="/xarpite/docs/ja/coroutine.html">コルーチン</a></li>
    <li><a href="/xarpite/docs/ja/json.html">JSON操作</a></li>
  </ul>
</nav>

                </aside>

                <article class="doc-content">
                    
                    
                        
                        
                        
                        
                            <div class="table-of-contents">
  <ul id="markdown-toc"><li><a href="#関数">関数</a></li><li><a href="#ラムダ式">ラムダ式</a><ul id="markdown-toc"><li><a href="#複数の引数を取るラムダ式">複数の引数を取るラムダ式</a></li><li><a href="#引数を取らないラムダ式">引数を取らないラムダ式</a></li><li><a href="#ラムダ演算子の引数部のより詳細な仕様">ラムダ演算子の引数部のより詳細な仕様</a><ul id="markdown-toc"><li><a href="#引数部の基本形">引数部の基本形</a></li><li><a href="#改行時の区切り文字の省略">改行時の区切り文字の省略</a></li><li><a href="#区切り文字の置き換え">区切り文字の置き換え</a></li><li><a href="#丸括弧の省略">丸括弧の省略</a></li><li><a href="#引数名の省略">引数名の省略</a></li></ul></li><li><a href="#引数列">引数列</a><ul id="markdown-toc"><li><a href="#ストリームを含む引数列">ストリームを含む引数列</a></li></ul></li></ul></li><li><a href="#関数化演算子">関数化演算子</a><ul id="markdown-toc"><li><a href="#関数適用演算子-body">関数適用演算子 *body</a></li></ul></li><li><a href="#関数呼び出し">関数呼び出し</a><ul id="markdown-toc"><li><a href="#異なる個数の引数による呼び出し">異なる個数の引数による呼び出し</a></li><li><a href="#関数の部分適用">関数の部分適用</a></li><li><a href="#中置関数呼び出し">中置関数呼び出し</a><ul id="markdown-toc"><li><a href="#否定中置換数呼び出し">否定中置換数呼び出し</a></li></ul></li><li><a href="#関数呼び出しへの代入">関数呼び出しへの代入</a></li></ul></li><li><a href="#メソッド呼び出し">メソッド呼び出し</a><ul id="markdown-toc"><li><a href="#メソッド呼び出しの部分適用">メソッド呼び出しの部分適用</a></li><li><a href="#メソッド参照">メソッド参照</a></li><li><a href="#関数へのメソッド呼び出し">関数へのメソッド呼び出し</a></li><li><a href="#null安全">NULL安全</a></li><li><a href="#フォールバックメソッド">フォールバックメソッド</a></li><li><a href="#ストリームへのメソッド呼び出し">ストリームへのメソッド呼び出し</a><ul id="markdown-toc"><li><a href="#フォールバックメソッドによるメソッド実装のスイッチ">フォールバックメソッドによるメソッド実装のスイッチ</a></li></ul></li></ul></li><li><a href="#クロージャ付き関数呼び出し">クロージャ付き関数呼び出し</a><ul id="markdown-toc"><li><a href="#バリエーション">バリエーション</a></li></ul></li><li><a href="#名前付き引数">名前付き引数</a></li><li><a href="#拡張関数">拡張関数</a><ul id="markdown-toc"><li><a href="#拡張関数の基本">拡張関数の基本</a></li><li><a href="#拡張関数のオーバーロード">拡張関数のオーバーロード</a></li><li><a href="#マウントを使用した拡張関数">マウントを使用した拡張関数</a></li><li><a href="#メソッドと拡張関数の優先順位">メソッドと拡張関数の優先順位</a></li></ul></li><li><a href="#組み込み定数">組み込み定数</a><ul id="markdown-toc"><li><a href="#call-関数を呼び出す">CALL 関数を呼び出す</a></li></ul></li></ul>
</div>


<h1 id="関数">関数</h1>

<p>Xarpiteでは、関数は数値や文字列などと同様に、変数に代入可能な値の一種として扱われます。</p>

<p>具体的には、ラムダ演算子 <code class="language-plaintext highlighter-rouge">arguments -&gt; formula</code> 等によって関数オブジェクトを生成し、それを必要に応じて変数等に代入し、関数呼び出し演算子 <code class="language-plaintext highlighter-rouge">function(argument; ...)</code> 等によって実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  plus := x, y -&gt; x + y
  plus(3; 4)
'</span>
<span class="c"># 7</span>
</code></pre></div></div>

<h1 id="ラムダ式">ラムダ式</h1>

<p>ラムダ演算子 <code class="language-plaintext highlighter-rouge">arguments -&gt; formula</code> は、関数オブジェクトを生成する演算子です。</p>

<p><code class="language-plaintext highlighter-rouge">-&gt;</code> の左辺に引数名を、右辺に呼び出し結果となる式を記述します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := x -&gt; x + 23
  f(100)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="複数の引数を取るラムダ式">複数の引数を取るラムダ式</h2>

<p>引数名をカンマ <code class="language-plaintext highlighter-rouge">,</code> で区切ることで、複数の引数を取る関数オブジェクトを生成できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := x, y -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="引数を取らないラムダ式">引数を取らないラムダ式</h2>

<p>引数がない場合は、 <code class="language-plaintext highlighter-rouge">() -&gt; formula</code> のように書きます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := () -&gt; 123
  f()
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="ラムダ演算子の引数部のより詳細な仕様">ラムダ演算子の引数部のより詳細な仕様</h2>

<h3 id="引数部の基本形">引数部の基本形</h3>

<p>ラムダ演算子の引数部の基本形は、引数名を <code class="language-plaintext highlighter-rouge">(argument; ...) -&gt; formula</code> のように <code class="language-plaintext highlighter-rouge">;</code> で区切り、 <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">)</code> で囲ったものです。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := (x; y) -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h3 id="改行時の区切り文字の省略">改行時の区切り文字の省略</h3>

<p>引数部を改行した場合、 <code class="language-plaintext highlighter-rouge">;</code> は改行で代用可能というルールに従って、区切り文字を省略できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := (
    x
    y
  ) -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h3 id="区切り文字の置き換え">区切り文字の置き換え</h3>

<p>引数部の区切り文字は、自由に <code class="language-plaintext highlighter-rouge">,</code> に置き換えることができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := (x, y) -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h3 id="丸括弧の省略">丸括弧の省略</h3>

<p>引数部が <code class="language-plaintext highlighter-rouge">;</code> で区切られていない場合、 <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">)</code> を省略できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := x, y -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h3 id="引数名の省略">引数名の省略</h3>

<p>区切り文字で区切られた引数名は省略できます。</p>

<p>その場合、余分な区切り文字は単に無視されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := (x; ; y) -&gt; x + y
  f(100; 23)
'</span>
<span class="c"># 123</span>

<span class="nv">$ </span>xa <span class="s1">'
  f := , -&gt; 123
  f()
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="引数列">引数列</h2>

<p>変数 <code class="language-plaintext highlighter-rouge">__</code> には、与えられたすべての引数が配列で渡されます。</p>

<p>これにより、ストリームを使う以外の方法で可変長引数を受け取ることができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := () -&gt; "$__"
  f(100; 20; 3)
'</span>
<span class="c"># [100;20;3]</span>
</code></pre></div></div>

<h3 id="ストリームを含む引数列">ストリームを含む引数列</h3>

<p>引数列では、引数に指定されたストリームを展開せずにそのまま受け取ることができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  f := () -&gt; __.1
  f(NULL; 1 .. 3; NULL)
'</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
<span class="c"># 3</span>
</code></pre></div></div>

<h1 id="関数化演算子">関数化演算子</h1>

<p>前置 <code class="language-plaintext highlighter-rouge">\</code> 演算子は、 <code class="language-plaintext highlighter-rouge">_ -&gt; body</code> というラムダ式と等しい関数を生成する演算子です。</p>

<p>後置版 <code class="language-plaintext highlighter-rouge">body.\\</code> も存在します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'(_ -&gt; 10)(200)'</span>
<span class="c"># 10</span>

<span class="nv">$ </span>xa <span class="s1">'(\10)(200)'</span>
<span class="c"># 10</span>

<span class="nv">$ </span>xa <span class="s1">'(\(10 + _))(200)'</span>
<span class="c"># 210</span>

<span class="nv">$ </span>xa <span class="s1">'(10 + _).\(200)'</span>
<span class="c"># 210</span>
</code></pre></div></div>

<hr />

<p>関数化演算子は、 <code class="language-plaintext highlighter-rouge">FILTER</code> や <code class="language-plaintext highlighter-rouge">SORT</code> などの関数を受け取る関数と組み合わせると便利です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  {name: "Bob"; age: 30},
  {name: "Alice"; age: 25},
  &gt;&gt; SORT[by: \_.name]
'</span>
<span class="c"># {name:Alice;age:25}</span>
<span class="c"># {name:Bob;age:30}</span>
</code></pre></div></div>

<h2 id="関数適用演算子-body">関数適用演算子 <code class="language-plaintext highlighter-rouge">*body</code></h2>

<p>前置 <code class="language-plaintext highlighter-rouge">*</code> 演算子は、関数に対して変数 <code class="language-plaintext highlighter-rouge">_</code> を唯一の引数として呼び出す演算子です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'10 | *(x -&gt; 10)'</span>
<span class="c"># 10</span>

<span class="nv">$ </span>xa <span class="s1">'10 | *(x -&gt; x)'</span>
<span class="c"># 10</span>

<span class="nv">$ </span>xa <span class="s1">'10 | *(x -&gt; x + 5)'</span>
<span class="c"># 15</span>
</code></pre></div></div>

<hr />

<p>関数適用演算子は、パイプと組み合わせると便利です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'-2 .. 2 | *ABS'</span>
<span class="c"># 2</span>
<span class="c"># 1</span>
<span class="c"># 0</span>
<span class="c"># 1</span>
<span class="c"># 2</span>
</code></pre></div></div>

<h1 id="関数呼び出し">関数呼び出し</h1>

<p>関数呼び出し演算子 <code class="language-plaintext highlighter-rouge">function(argument; ...)</code> は、関数オブジェクトなどの値を関数として実行する演算子です。</p>

<p>引数は <code class="language-plaintext highlighter-rouge">;</code> で区切ります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'JOIN("-"; 1, 2, 3)'</span>
<span class="c"># 1-2-3</span>
</code></pre></div></div>

<hr />

<p>関数呼び出しにおいて、カンマ <code class="language-plaintext highlighter-rouge">,</code> は引数の区切りではなく、ストリーム結合演算子であることに注意してください。</p>

<h2 id="異なる個数の引数による呼び出し">異なる個数の引数による呼び出し</h2>

<p>Xarpiteでは、ラムダ式で定義した引数と異なる個数の引数で関数呼び出しを行うことができます。</p>

<p>引数が足りない場合はNULLが渡され、多すぎる場合は単に無視されます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'(x, y -&gt; "$x, $y")(1)'</span>
<span class="c"># 1, NULL</span>

<span class="nv">$ </span>xa <span class="s1">'(x, y -&gt; "$x, $y")(1; 2; 3)'</span>
<span class="c"># 1, 2</span>
</code></pre></div></div>

<h2 id="関数の部分適用">関数の部分適用</h2>

<p>関数の部分適用 <code class="language-plaintext highlighter-rouge">function[argument; ...]</code> は、関数を実行せずに、「引数の適用を部分的に予約した関数」を生成します。</p>

<p>元の関数は、部分適用された関数の呼び出し時に、部分適用時に与えられた引数列の後に部分適用された関数の呼び出し時の引数列を受け取ります。</p>

<hr />

<p>言葉にするとややこしいですが、以下の例を見るのが簡単です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'JOIN("-"; 1, 2, 3)'</span>
<span class="c"># 1-2-3</span>

<span class="nv">$ </span>xa <span class="s1">'JOIN["-"](1, 2, 3)'</span>
<span class="c"># 1-2-3</span>

<span class="nv">$ </span>xa <span class="s1">'JOIN["-"; 1, 2, 3]()'</span>
<span class="c"># 1-2-3</span>

<span class="nv">$ </span>xa <span class="s1">'JOIN["-"][1, 2, 3]()'</span>
<span class="c"># 1-2-3</span>
</code></pre></div></div>

<hr />

<p>関数の部分適用は、「第1引数のみが既に指定された関数」のようなものを作れるため、しばしばストリームを操作する関数の扱いに役立ちます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'1, 2, 3 &gt;&gt; JOIN["-"]'</span>
<span class="c"># 1-2-3</span>
</code></pre></div></div>

<h2 id="中置関数呼び出し">中置関数呼び出し</h2>

<p>関数を表す変数を左右の値の間に書くことで、その関数を2引数で呼び出せます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  add := a, b -&gt; a + b

  100 add 23
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h3 id="否定中置換数呼び出し">否定中置換数呼び出し</h3>

<p><code class="language-plaintext highlighter-rouge">!</code> を <code class="language-plaintext highlighter-rouge">a !function b</code> のように関数名の前に書くことで、その結果を否定できます。
この書き方は <code class="language-plaintext highlighter-rouge">!(a function b)</code> と同じ意味になります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  in := item, array -&gt; item @ array

  OUT &lt;&lt; "banana"  in ["apple", "banana"] // TRUE
  OUT &lt;&lt; "cherry"  in ["apple", "banana"] // FALSE
  OUT &lt;&lt; "banana" !in ["apple", "banana"] // FALSE
  OUT &lt;&lt; "cherry" !in ["apple", "banana"] // TRUE
'</span>
<span class="c"># TRUE</span>
<span class="c"># FALSE</span>
<span class="c"># FALSE</span>
<span class="c"># TRUE</span>
</code></pre></div></div>

<h2 id="関数呼び出しへの代入">関数呼び出しへの代入</h2>

<p>関数呼び出しに対して代入すると、関数は、代入される値を引数列の末尾に受け取ります。</p>

<p>関数の戻り値は使われません。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  map := {}
  properties := key, value -&gt; map.(key) = value

  properties("fruit") = "apple"

  OUT &lt;&lt; map
'</span>
<span class="c"># {fruit:apple}</span>
</code></pre></div></div>

<hr />

<p>この動作は、 <code class="language-plaintext highlighter-rouge">_(__)=_</code> メソッドをオーバーライドすることでカスタマイズできます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  Properties := {
    `_(__)=_`: this, key, value -&gt; this.map.(key) = value
    new: () -&gt; Properties{map: {}}
  }

  properties := Properties.new()

  properties("fruit") = "apple"

  OUT &lt;&lt; properties
'</span>
<span class="c"># {map:{fruit:apple}}</span>
</code></pre></div></div>

<hr />

<p>配列要素やオブジェクト要素への代入も、技術的には関数呼び出しへの代入として実装されています。</p>

<h1 id="メソッド呼び出し">メソッド呼び出し</h1>

<p>メソッド呼び出し演算子 <code class="language-plaintext highlighter-rouge">receiver::method(argument; ...)</code> は、 <code class="language-plaintext highlighter-rouge">receiver</code> の祖先のオブジェクトに登録された関数を、 <code class="language-plaintext highlighter-rouge">receiver</code> とともに呼び出す演算子です。</p>

<p>引数列の先頭に <code class="language-plaintext highlighter-rouge">receiver</code> が追加されることを除き、細かい仕様は関数呼び出し演算子と共通です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  Adder := {
    add: this, y, z -&gt; this.x + y + z
  }
  adder := Adder{x: 100}

  adder::add(20; 3)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="メソッド呼び出しの部分適用">メソッド呼び出しの部分適用</h2>

<p>関数呼び出しと同じく、メソッド呼び出しも部分適用ができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  Adder := {
    add: this, y, z -&gt; this.x + y + z
  }
  adder := Adder{x: 100}

  adder::add[20](3)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="メソッド参照">メソッド参照</h2>

<p>メソッド参照 <code class="language-plaintext highlighter-rouge">receiver::method</code> は、値の先祖のオブジェクトに登録された関数に、その値を部分適用した関数を生成します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  Adder := {
    add: this, y, z -&gt; this.x + y + z
  }
  adder := Adder{x: 100}

  function := adder::add

  function(20; 3)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<hr />

<p>メソッド呼び出しは、概念的にはメソッド参照と関数呼び出しの組み合わせと等価です。</p>

<table>
  <thead>
    <tr>
      <th>演算子</th>
      <th>記法</th>
      <th>意味</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>メソッド呼び出し</td>
      <td><code class="language-plaintext highlighter-rouge">receiver::method(argument; ...)</code></td>
      <td><code class="language-plaintext highlighter-rouge">receiver</code> を挿入して関数を実行</td>
    </tr>
    <tr>
      <td>メソッド参照</td>
      <td><code class="language-plaintext highlighter-rouge">receiver::method</code></td>
      <td><code class="language-plaintext highlighter-rouge">receiver</code> を挿入</td>
    </tr>
    <tr>
      <td>関数呼び出し</td>
      <td><code class="language-plaintext highlighter-rouge">function(argument; ...)</code></td>
      <td>関数の実行</td>
    </tr>
  </tbody>
</table>

<h2 id="関数へのメソッド呼び出し">関数へのメソッド呼び出し</h2>

<p>メソッド名の代わりに関数を返す式を <code class="language-plaintext highlighter-rouge">( )</code> で囲んで指定すると、その関数をメソッドのように呼び出すことができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  add := a, b -&gt; a + b

  100::(add)(23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="null安全">NULL安全</h2>

<p><code class="language-plaintext highlighter-rouge">?::</code> 演算子は <code class="language-plaintext highlighter-rouge">receiver</code> が <code class="language-plaintext highlighter-rouge">NULL</code> の場合にメソッドを実行せず、代わりに <code class="language-plaintext highlighter-rouge">NULL</code> を返します。</p>

<table>
  <thead>
    <tr>
      <th>演算子</th>
      <th>記法</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NULL安全メソッド呼び出し</td>
      <td><code class="language-plaintext highlighter-rouge">receiver?::method(argument; ...)</code></td>
    </tr>
    <tr>
      <td>NULL安全メソッド呼び出しの部分適用</td>
      <td><code class="language-plaintext highlighter-rouge">receiver?::method[argument; ...]</code></td>
    </tr>
    <tr>
      <td>NULL安全メソッド参照</td>
      <td><code class="language-plaintext highlighter-rouge">receiver?::method</code></td>
    </tr>
  </tbody>
</table>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  Object := {
    get_name: this -&gt; this.name
  }

  object1 := Object{name: 1}
  object2 := NULL
  object3 := Object{name: 3}

  object1, object2, object3 | _?::get_name()
'</span>
<span class="c"># 1</span>
<span class="c"># NULL</span>
<span class="c"># 3</span>
</code></pre></div></div>

<h2 id="フォールバックメソッド">フォールバックメソッド</h2>

<p>レシーバに定義されていないメソッドの参照が行われた際、 <code class="language-plaintext highlighter-rouge">_::_</code> メソッドが呼び出されます。</p>

<p>フォールバックメソッドは、レシーバとメソッド名を引数として受け取り、「引数を受け取ると結果を返す関数」もしくはNULLを返します。</p>

<p>フォールバックメソッドがNULLを返した場合、フォールバックメソッドが定義されていない場合と同じ動作になります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  Obj := {
    `_::_`: this, method -&gt; () -&gt; "$method$__ called"
  }
  obj := Obj{}

  OUT &lt;&lt; obj::apple()
  OUT &lt;&lt; obj::banana(1)
  OUT &lt;&lt; obj::cherry(1; 2; 3)
'</span>
<span class="c"># apple[] called</span>
<span class="c"># banana[1] called</span>
<span class="c"># cherry[1;2;3] called</span>
</code></pre></div></div>

<h2 id="ストリームへのメソッド呼び出し">ストリームへのメソッド呼び出し</h2>

<p>ストリームへの通常のメソッドの呼び出しは、各要素のメソッド呼び出しの結果のストリームになります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'("baa", "aba", "aab")::replace("b"; "c")'</span>
<span class="c"># caa</span>
<span class="c"># aca</span>
<span class="c"># aac</span>
</code></pre></div></div>

<p>これは以下のような呼び出しに相当します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'("baa", "aba", "aab") | _::replace("b"; "c")'</span>
<span class="c"># caa</span>
<span class="c"># aca</span>
<span class="c"># aac</span>

<span class="nv">$ </span>xa <span class="s1">'
  "baa"::replace("b"; "c"),
  "aba"::replace("b"; "c"),
  "aab"::replace("b"; "c"),
'</span>
<span class="c"># caa</span>
<span class="c"># aca</span>
<span class="c"># aac</span>
</code></pre></div></div>

<h3 id="フォールバックメソッドによるメソッド実装のスイッチ">フォールバックメソッドによるメソッド実装のスイッチ</h3>

<p>フォールバックメソッドは、次のようにメソッドの実装を切り替えるスイッチとして使うことができます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  Obj := {
    `_::_`: this, method -&gt;
      method == "apple"  ? this::apple_impl :
      method == "banana" ? this::banana_impl :
      method == "cherry" ? this::cherry_impl :
                           NULL
    apple_impl : this          -&gt; "apple[] called"
    banana_impl: this, x       -&gt; "banana[$x] called"
    cherry_impl: this, x, y, z -&gt; "cherry[$x;$y;$z] called"
  }
  obj := Obj{}

  OUT &lt;&lt; obj::apple()
  OUT &lt;&lt; obj::banana(1)
  OUT &lt;&lt; obj::cherry(1; 2; 3)
  OUT &lt;&lt; obj::durian(1; 2; 3; 4; 5; 6) !? (e =&gt; e)
'</span>
<span class="c"># apple[] called</span>
<span class="c"># banana[1] called</span>
<span class="c"># cherry[1;2;3] called</span>
<span class="c"># Method not found: {}::durian</span>
</code></pre></div></div>

<h1 id="クロージャ付き関数呼び出し">クロージャ付き関数呼び出し</h1>

<p>クロージャ付き関数呼び出し <code class="language-plaintext highlighter-rouge">function ( arguments =&gt; block )</code> は、関数 <code class="language-plaintext highlighter-rouge">function</code> に <code class="language-plaintext highlighter-rouge">block</code> 部分を関数として渡すことで呼び出します。</p>

<p><code class="language-plaintext highlighter-rouge">block</code> 部分には文も記述できます。</p>

<p>イベントリスナーの登録などで用いると、可読性に貢献する可能性があります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  register := listener -&gt; (
    event := {x: 100; y: 200}
    listener(event)
  )

  register ( event =&gt;
    string := "X: $(event.x), Y: $(event.y)"
    OUT &lt;&lt; string
  )
'</span>
<span class="c"># X: 100, Y: 200</span>
</code></pre></div></div>

<h2 id="バリエーション">バリエーション</h2>

<p>クロージャ付き関数呼び出しは、メソッド呼び出しや関数の部分適用としても書くことができます。</p>

<h1 id="名前付き引数">名前付き引数</h1>

<p>名前付き引数専用の文法はありませんが、エントリー演算子を使って近いことが実現できます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="nt">-q</span> <span class="s1">'
  f := a1 -&gt; (
    params := {__(1 ~ $#__)}

    OUT &lt;&lt; "a1=$(a1)"
    OUT &lt;&lt; "p1=$(params.p1)"
    OUT &lt;&lt; "p2=$(params.p2)"
    OUT &lt;&lt; "p3=$(params.p3)"
  )

  f("arg1"; p1: "param1"; p2: "param2")
'</span>
<span class="c"># a1=arg1</span>
<span class="c"># p1=param1</span>
<span class="c"># p2=param2</span>
<span class="c"># p3=NULL</span>
</code></pre></div></div>

<h1 id="拡張関数">拡張関数</h1>

<p>拡張関数は、変数やマウント上で定義された関数をオブジェクトのメソッドのように呼び出すことができる仕組みです。</p>

<h2 id="拡張関数の基本">拡張関数の基本</h2>

<p>拡張関数の基本的な構文は次の通りです。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`::method` := (class): this, arguments -&gt; formula
</code></pre></div></div>

<hr />

<p>これは、次のように分解できます。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function   := this, arguments -&gt; formula
entry      := (class): function
`::method` := entry
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">function</code> は、メソッドの本体となる関数です。</p>

<p><code class="language-plaintext highlighter-rouge">entry</code> は、対象となるクラスと <code class="language-plaintext highlighter-rouge">function</code> の組です。</p>

<p>エントリー演算子 <code class="language-plaintext highlighter-rouge">key: value</code> は、 <code class="language-plaintext highlighter-rouge">key</code> が識別子の場合にそれを文字列として扱うため、クラスを参照するには丸括弧が必要です。</p>

<p>変数名には <code class="language-plaintext highlighter-rouge">::</code> の接頭辞が必要です。</p>

<p>変数名に記号を含むため、バッククォート <code class="language-plaintext highlighter-rouge">`</code> で囲う必要があります。</p>

<hr />

<p>以下は実際に拡張関数を使用する例です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  Adder := {}

  `::add` := (Adder): this, y -&gt; this.x + y

  Adder{x: 100}::add(23)
'</span>
<span class="c"># 123</span>
</code></pre></div></div>

<h2 id="拡張関数のオーバーロード">拡張関数のオーバーロード</h2>

<p>拡張関数のエントリーは、エントリーの配列でもかまいません。</p>

<p>その場合、配列内のすべてのエントリーが有効になります。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  NumberAdder := {}
  StringAdder := {}

  `::add` := [
    (NumberAdder): this, y -&gt; this.x + y
    (StringAdder): this, y -&gt; this.x &amp; y
  ]

  NumberAdder{x: 100}::add(23),
  StringAdder{x: "a"}::add("bc"),
'</span>
<span class="c"># 123</span>
<span class="c"># abc</span>
</code></pre></div></div>

<h2 id="マウントを使用した拡張関数">マウントを使用した拡張関数</h2>

<p>同名の変数は後に宣言したものが上書きする関係があるため、拡張関数の定義には不便です。</p>

<p>そのため、マウントを使用して拡張関数を定義することもできます。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  NumberAdder := {}
  StringAdder := {}

  @{
    `::add`: (NumberAdder): this, y -&gt; this.x + y
  }
  @{
    `::add`: (StringAdder): this, y -&gt; this.x &amp; y
  }

  NumberAdder{x: 100}::add(23),
  StringAdder{x: "a"}::add("bc"),
'</span>
<span class="c"># 123</span>
<span class="c"># abc</span>
</code></pre></div></div>

<p>メソッド名の解決時には、すべての同名のエントリーが検索の対象となります。</p>

<hr />

<p>マウントを使用した拡張関数も、配列によるオーバーロードが可能です。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  NumberAdder := {}
  StringAdder := {}

  @{
    `::add`: [
      (NumberAdder): this, y -&gt; this.x + y
      (StringAdder): this, y -&gt; this.x &amp; y
    ]
  }

  NumberAdder{x: 100}::add(23),
  StringAdder{x: "a"}::add("bc"),
'</span>
<span class="c"># 123</span>
<span class="c"># abc</span>
</code></pre></div></div>

<h2 id="メソッドと拡張関数の優先順位">メソッドと拡張関数の優先順位</h2>

<p>同名のメソッドの定義が複数存在した場合、以下の順に優先します。</p>

<ol>
  <li>変数による拡張関数</li>
  <li>そのオブジェクトのメソッド</li>
  <li>そのオブジェクトのフォールバックメソッド</li>
  <li>マウントによる拡張関数</li>
</ol>

<p>変数による拡張関数がオブジェクトのメソッドよりも優先されることに注意してください。</p>

<p>これは、変数は静的解決であり、オブジェクトのメソッドは動的解決であることに起因する仕様です。</p>

<h1 id="組み込み定数">組み込み定数</h1>

<h2 id="call-関数を呼び出す"><code class="language-plaintext highlighter-rouge">CALL</code> 関数を呼び出す</h2>

<p><code class="language-plaintext highlighter-rouge">CALL(function: FUNCTION; arguments: ARRAY&lt;VALUE&gt;): VALUE</code></p>

<p>第1引数の関数に対し、第2引数の配列の各要素を引数として渡して実行します。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xa <span class="s1">'
  function := a, b -&gt; a * b

  CALL(function; [2; 3])
'</span>
<span class="c"># 6</span>
</code></pre></div></div>

                        
                    
                </article>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <p class="footer-text">
                    &copy; 2024-2025 <a href="https://github.com/MirrgieRiana" target="_blank" class="footer-link">MirrgieRiana</a>.
                    <a href="https://github.com/MirrgieRiana/xarpite" target="_blank" class="footer-link">GitHub</a>
                </p>
            </div>
        </div>
    </footer>
</div>
</body>
</html>
