name: Make Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      commit_hash:
        description: 'Commit Hash'
        default: HEAD
        required: true
        type: string

concurrency:
  group: make-release-${{ github.repository }}
  cancel-in-progress: false

jobs:
  create_tag:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:

      - name: リポジトリのチェックアウト
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MAKE_RELEASE_WORKFLOW_PAT }}

      - name: 最新のバージョンタグを取得
        id: get_version
        env:
          RELEASE_TYPE: ${{ inputs.release_type }}
        run: |
          # リモートのタグをフェッチ
          git fetch --tags

          # 最新のバージョンタグを取得（v1.2.3形式のみ）
          LATEST_TAG=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n 1)

          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v0.0.0"
          fi

          echo "Latest tag: $LATEST_TAG"

          # バージョン番号を抽出（vプレフィックスを除去）
          VERSION=${LATEST_TAG#v}

          # バージョン番号の形式を検証
          if ! echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Error: Invalid version format: $VERSION" >&2
            exit 1
          fi

          # バージョン番号を分割
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # 新しいバージョンを計算
          case "$RELEASE_TYPE" in
            patch)
              PATCH=$((PATCH + 1))
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=$((MINOR + 1))  # このプロジェクト独自の仕様: メジャーリリースではマイナーもインクリメント（SEMVER標準では0にリセット）
              PATCH=0
              ;;
            *)
              echo "Error: Invalid release type: $RELEASE_TYPE" >&2
              exit 1
              ;;
          esac

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "New tag: $NEW_TAG"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: コミットの検証
        env:
          COMMIT: ${{ inputs.commit_hash }}
        run: |

          # コミットが存在するか確認
          if ! git cat-file -e "$COMMIT^{commit}" 2>/dev/null; then
            echo "Error: No such commit: $COMMIT" >&2
            exit 1
          fi

          # コミットがmainブランチの経路上にあるか確認
          if ! git merge-base --is-ancestor "$COMMIT" main; then
            echo "Error: Commit is not in main: $COMMIT" >&2
            exit 1
          fi

          echo "Commit Hash: $COMMIT"

      - name: タグの作成とプッシュ
        env:
          TAG: ${{ steps.get_version.outputs.tag }}
          COMMIT: ${{ inputs.commit_hash }}
        run: |

          # リモートのタグをフェッチ
          git fetch --tags

          # タグが既に存在するか確認（ローカルとリモート両方）
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Error: Duplicated tag: $TAG" >&2
            exit 1
          fi

          # タグを作成
          git tag "$TAG" "$COMMIT"

          # タグをプッシュ
          if ! git push origin "$TAG"; then
            echo "Error: Can not push" >&2
            exit 1
          fi

          echo "OK: $TAG -> $COMMIT"
